<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-rust/rust基础入门/index">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">rust 基础入门 | 学习笔记</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-test-site.com/festudy/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-test-site.com/festudy/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/festudy/docs/rust/rust基础入门/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="rust 基础入门 | 学习笔记"><meta data-rh="true" name="description" content="3.数据"><meta data-rh="true" property="og:description" content="3.数据"><link data-rh="true" rel="icon" href="/festudy/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/festudy/docs/rust/rust基础入门/"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/festudy/docs/rust/rust基础入门/" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/festudy/docs/rust/rust基础入门/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/festudy/blog/rss.xml" title="学习笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/festudy/blog/atom.xml" title="学习笔记 Atom Feed"><link rel="stylesheet" href="/festudy/assets/css/styles.4aeb8efa.css">
<link rel="preload" href="/festudy/assets/js/runtime~main.8a7bcb99.js" as="script">
<link rel="preload" href="/festudy/assets/js/main.7be96d69.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/festudy/"><div class="navbar__logo"><img src="/festudy/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/festudy/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">杂七杂八</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/festudy/docs/前言">学习笔记</a><a class="navbar__item navbar__link" href="/festudy/blog">博客文章</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/chovrio" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/festudy/docs/前言">前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/festudy/docs/html/">html 内容</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/festudy/docs/css/">css</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/festudy/docs/js/">js 内容</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/festudy/docs/advance/">进阶</a><button aria-label="Toggle the collapsible sidebar category &#x27;进阶&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/festudy/docs/手写题/">手写题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/festudy/docs/webpack/">webpack</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/festudy/docs/category/算法学习记录">算法学习记录</a><button aria-label="Toggle the collapsible sidebar category &#x27;算法学习记录&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/festudy/docs/category/rust">rust</a><button aria-label="Toggle the collapsible sidebar category &#x27;rust&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/festudy/docs/rust/rust基础入门/">rust 基础入门</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/festudy/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/festudy/docs/category/rust"><span itemprop="name">rust</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">rust 基础入门</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>rust 基础入门</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3数据">3.数据<a href="#3数据" class="hash-link" aria-label="Direct link to 3.数据" title="Direct link to 3.数据">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-变量与可变性">3.1 变量与可变性<a href="#31-变量与可变性" class="hash-link" aria-label="Direct link to 3.1 变量与可变性" title="Direct link to 3.1 变量与可变性">​</a></h3><ul><li>声明变量使用 let 关键字。</li><li>默认情况下，变量是不可变的(immutable)。</li><li>声明变量时，在变量前面加上 mut，就可以使变量可变。</li></ul><p><strong>变量与常量</strong></p><ul><li>常量(constant)，常量绑定以后也是不可变的，但是它与不可变的变量有很多区别：<ul><li>不可以使用 mut，常量永远都是不可变的</li><li>声明常量使用 const 关键字，它的类型必须被标注</li><li>常量可以在任何作用域内及进行声明，包括全局作用域</li><li>常量只可以绑定到常量表达式，无法绑定到函数的调用结构或只能在运行时才能计算出的值</li></ul></li><li>在程序运行期间，常量在其声明的作用域内一直有效</li><li>命名规范：Rust 里常量使用全大写字母，每个单词之间用下划线分开，例如<ul><li>MAX_POINTS</li></ul></li></ul><p><strong>隐藏(shadowing)</strong></p><ul><li>可以使用相同的名字声明新的变量，新的变量就会 shadow(隐藏)之前声明的相同变量<ul><li>在后续的代码中这个变量名就是心的变量</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let x = x + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println!(&quot;{}&quot;,x);// 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>shadow 和把变量标记为 mut 是不一样的：<ul><li>如果不适用 let 关键之，那么重新给非 mut 的变量赋值会导致编译时错误</li><li>而使用 let 声明的同名新变量，也是不可变的。</li><li>使用 let 声明的同名新变量，它的类型可以与之前不同</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let spaces = &quot;    &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let spaces = spaces.len();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, spaces);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="32-数据类型">3.2 数据类型<a href="#32-数据类型" class="hash-link" aria-label="Direct link to 3.2 数据类型" title="Direct link to 3.2 数据类型">​</a></h3><ul><li>标量和复合类型</li><li>Rust 是静态编译语言，在编译时必须直到所有变量的类型<ul><li>基于使用的值，编译器通常能够推断出它的具体类型</li><li>但如果可能的类型比较多(例如把 String 转为整数的 parse 方法)，就必须添加类型的标注，否则编译会报错</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> // 不写 u32 类型就报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><p><strong>标量类型</strong></p><ul><li>一个变量类型代表一个单个的值</li><li>Rust 有四个主要的标量类型<ul><li>整数类型</li><li>浮点类型</li><li>布尔类型</li><li>字符类型</li></ul></li></ul><p><strong>整数类型</strong></p><ul><li>整数类型没有小数部分</li><li>例如 u32 就是一个无符号的整数类型，占据 32 位的空间</li><li>无符号整数类型以 u 开头</li><li>有符号整数类型以 i 开头</li><li>Rust 的整数类型 ：8 16 32 64 128 arch(size)<ul><li>每种都分 i 和 u，以及固定的位数</li><li>有符号范围:<ul><li>-(2^n-1)到 2^(n-1)-1</li></ul></li><li>无符号范围：<ul><li>0 到 2^n - 1</li></ul></li></ul></li></ul><p><strong>isize 和 usize 类型</strong></p><ul><li>isize 和 usize 类型的位数由程序运行的计算机的架构所决定：<ul><li>如果是 64 位计算机，那就是 64 位的</li><li>(其余同理)....</li></ul></li><li>使用 isize 或 usize 的主要场景是对某种集合进行索引操作。</li></ul><p><strong>整数字面量</strong></p><ul><li>除了 byte 类型外，所有的数值字面值都允许使用类型后缀。<ul><li>例如 57u8</li></ul></li><li>如果你不太清楚应该使用哪种类型，可以使用 Rust 相应的默认类型</li><li>整数的默认类型就是 u32</li></ul><p><strong>整数溢出</strong></p><ul><li>例如： u8 的范围是 0-255，如果你把一个 u8 变量的值设为 256，那么：<ul><li>调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic</li><li>发布模式下(-release)编译：Rust 不会检查可能导致 panic 的整数溢出<ul><li>如果溢出发生：Rust 会执行“环绕”操作：<ul><li>256 变成 0 ，257 变成 1 ...</li></ul></li><li>但是程序不会 panic</li></ul></li></ul></li></ul><p><strong>浮点类型</strong></p><ul><li>Rust 有两种基础的浮点类型，也就是含有小数部分的类型<ul><li>f32，32 位，单精度</li><li>f64，64 位，双精度</li></ul></li><li>Rust 的浮点类型使用了 IEEE-754 标准来表述</li><li>f64 时默认内心，因为在现代 CPU 上 f64 和 f32 的速度差不多，而且精度更高。</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let x = 2.0; // f64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let y: f32 = 3.0; // f32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>数值操作</strong></p><p>加减乘除没啥好说的</p><p><strong>布尔类型</strong></p><p>和其它语言也一样，没啥好说的</p><p><strong>字符类型</strong></p><ul><li>Rust 语言中 char 类型被用来描述语言中最基础的单个字符。</li><li>字符类型的字面值使用单引号</li><li>占用 4 字节大小</li><li>是 Unicode 的标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji 表情等<ul><li>U+0000 到 U+D7FF</li><li>U+E000 到 U+10FFFF</li></ul></li><li>但 Unicode 中并没有“字符”的改良，所以直觉上认为的字符也许与 Rust 中的概念并不相符</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="33-复合类型">3.3 复合类型<a href="#33-复合类型" class="hash-link" aria-label="Direct link to 3.3 复合类型" title="Direct link to 3.3 复合类型">​</a></h3><ul><li>复合类型可以将多个值放在一个类型中</li><li>Rust 提供了两种基础的复合类型：元组(Tuple)、数组</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tuple">Tuple<a href="#tuple" class="hash-link" aria-label="Direct link to Tuple" title="Direct link to Tuple">​</a></h4><p><strong>创建 Tuple</strong></p><ul><li>在小括号里面，将值用逗号分开</li><li>Tuple 中的每个位置都对应一个类型，Tuple 中各元素的类型不必相同</li></ul><p><strong>获取 Tuple 的元素值</strong></p><ul><li>可以使用模式匹配来解构（destructure）一个 Tuple 来获取元素的值</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let tup: (i32, f64, i32) = (500, 6.4, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 解构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (x, y, z) = tup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{},{},{}&quot;, x, y, z);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{},{},{}&quot;, tup.0, tup.1, tup.2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="数组">数组<a href="#数组" class="hash-link" aria-label="Direct link to 数组" title="Direct link to 数组">​</a></h4><ul><li>数组也可以将多个值放在一个类型里</li><li>数组中每个元素的类型必须相同</li><li>数组的长度也是固定的</li></ul><p><strong>声明一个数组</strong></p><ul><li>在中括号里，各值用逗号分开</li></ul><p><strong>数组的用处</strong></p><ul><li>如果想让你的数据存放在 stack(栈)上而不是 heap(堆)上，或者想保证有固定数量的元素，这时使用数组更有好处</li><li>数组没有 Vector 灵活<ul><li>Vector 和数组类似，它由标准库提供</li><li>Vector 的长度可以改变</li><li>如果你不确定应该使用数组还是 Vector，那么估计你应该用 Vector</li></ul></li></ul><p><strong>数组的类型</strong></p><ul><li><p>数组的类型以这种形式表示: <!-- -->[类型; 长度]</p><ul><li>例如 let a:<!-- -->[i32;5]<!-- --> = <!-- -->[1,2,3,4,5]<!-- -->;</li></ul></li></ul><p><strong>另一种声明数组的方法</strong></p><ul><li>如果数组的每个元素的值都相同,那么可以在:<ul><li>在中括号里指定初始值</li><li>然后是一个&quot;; &quot;</li><li>最后是数组的长度</li></ul></li><li>例如: let a = <!-- -->[3; 5]<!-- -->; 它相当于: let a = <!-- -->[3,3,3,3,3]</li></ul><p><strong>访问数组的元素</strong></p><ul><li>数组时 Stack 上分配的单个块的内存</li><li>可以使用索引来访问数组的元素(例子 )</li><li>如果访问的索引超出了数组的范围,那么:<ul><li>编译会通过</li><li>运行会报错(runtime 时会 panic)<ul><li>Rust 不会允许其继续访问相应地址的内存</li></ul></li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let months: [&amp;str; 12] = [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;January&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;February&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;March&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;April&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;May&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;June&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;July&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;Auguest&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;September&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;October&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;November&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;December&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let first = months[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let second = months[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let index = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let month = months[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, month);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="34-函数">3.4 函数<a href="#34-函数" class="hash-link" aria-label="Direct link to 3.4 函数" title="Direct link to 3.4 函数">​</a></h3><ul><li>声明函数使用 fn 关键字</li><li>依照惯例:针对函数和变量名,Rust 使用 stack case 命名规范:<ul><li>所有的字母都是小写的,单词之间使用下划线分开</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="函数的参数">函数的参数<a href="#函数的参数" class="hash-link" aria-label="Direct link to 函数的参数" title="Direct link to 函数的参数">​</a></h4><ul><li>parameters,arguments</li><li>在函数签名里,必须声明每个参数的类型</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="函数体中的语句与表达式">函数体中的语句与表达式<a href="#函数体中的语句与表达式" class="hash-link" aria-label="Direct link to 函数体中的语句与表达式" title="Direct link to 函数体中的语句与表达式">​</a></h4><ul><li>函数体由一系列语句组成,可选的由一个表达式结束</li><li>Rust 是一个基于表达式的语言</li><li>语句是执行一些动作的指令</li><li>表达式会计算产生一个值</li><li>函数的定义也是一个语句</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="函数的返回值">函数的返回值<a href="#函数的返回值" class="hash-link" aria-label="Direct link to 函数的返回值" title="Direct link to 函数的返回值">​</a></h4><ul><li>在 -&gt; 符号后边声明函数返回值的类型,但是不可以为返回值命名</li><li>在 Rust 里面,返回值就是函数体里面最后一个表达式的值</li><li>若想提前返回,需使用 return 关键字,并指定一个值<ul><li>大多数函数都是默认使用最后一个表达式最为返回值</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="函数注释">函数注释<a href="#函数注释" class="hash-link" aria-label="Direct link to 函数注释" title="Direct link to 函数注释">​</a></h4><p>和 js 一样</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    another_function(5); // argument</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let x = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 不加分号返回 x + 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // x + 3; //()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x + 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The value of plus_five(10) is:{}&quot;, plus_five(10));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The value of y is:{}&quot;, y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn another_function(x: i32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // parameter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;the value of x is:{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn plus_five(x: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x + 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="35-控制流">3.5 控制流<a href="#35-控制流" class="hash-link" aria-label="Direct link to 3.5 控制流" title="Direct link to 3.5 控制流">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="if-表达式">if 表达式<a href="#if-表达式" class="hash-link" aria-label="Direct link to if 表达式" title="Direct link to if 表达式">​</a></h4><ul><li>if 表达式允许您根据条件来执行不同的代码分支<ul><li>这个条件必须 bool 类型</li></ul></li><li>if 表达式中,与条件相关联的代码块就叫分支(arm)</li><li>可选的,在后边可以加上一个 else 表达式</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="使用-else-if-处理多重条件">使用 else if 处理多重条件<a href="#使用-else-if-处理多重条件" class="hash-link" aria-label="Direct link to 使用 else if 处理多重条件" title="Direct link to 使用 else if 处理多重条件">​</a></h4><ul><li>但如果使用了多于一个 else if,那么最好使用 match 来重构代码</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let number = 7;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if number &lt; 5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;condition was true&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if number &gt; 1000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;too big&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;condition was false&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let condition = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let number = if condition { 5 } else { 6 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The value of number is: {}&quot;, number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="rust-的循环">Rust 的循环<a href="#rust-的循环" class="hash-link" aria-label="Direct link to Rust 的循环" title="Direct link to Rust 的循环">​</a></h3><ul><li>Rust 提供了 3 种循环:loop,while 和 for</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="loop-循环">loop 循环<a href="#loop-循环" class="hash-link" aria-label="Direct link to loop 循环" title="Direct link to loop 循环">​</a></h4><ul><li>loop 关键字告诉 Rust 反复的执行一块代码,直到你喊停</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="while-条件循环">while 条件循环<a href="#while-条件循环" class="hash-link" aria-label="Direct link to while 条件循环" title="Direct link to while 条件循环">​</a></h4><ul><li>另一种常见的循环模式是每次执行循环体之前都判断一次条件.</li><li>while 条件循环为这种模式而生</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="使用-for-循环遍历集合">使用 for 循环遍历集合<a href="#使用-for-循环遍历集合" class="hash-link" aria-label="Direct link to 使用 for 循环遍历集合" title="Direct link to 使用 for 循环遍历集合">​</a></h4><ul><li>可以使用 while 或 loop 来遍历集合,但是易错且低效</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = [10, 20, 30, 40, 50];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut index = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while index &lt; 5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;The value of a[index] is: {}&quot;, a[index]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        index = index + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for element in a.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;element: {}&quot;, element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while i &lt;= 3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i = i + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;while {}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i = i + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;loop {}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if i &gt;= 10 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="range">Range<a href="#range" class="hash-link" aria-label="Direct link to Range" title="Direct link to Range">​</a></h4><ul><li>标准库提供</li><li>指定一个开始数字和一个结束数字,Range 可以生成它们之间的数字(不含结束)</li><li>rev 方法可以反转 Range</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for number in (1..4).rev() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}!&quot;, number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;LIFTOFF!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4所有权">4.所有权<a href="#4所有权" class="hash-link" aria-label="Direct link to 4.所有权" title="Direct link to 4.所有权">​</a></h2><ul><li>所有权是 Rust 最独特的特性,它让 Rust 无需 GC(垃圾收集器) 就可以保证内存安全</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-什么是所有权">4.1 什么是所有权<a href="#41-什么是所有权" class="hash-link" aria-label="Direct link to 4.1 什么是所有权" title="Direct link to 4.1 什么是所有权">​</a></h3><ul><li>Rust 的核心特性就是所有权</li><li>所有程序在运行时都必须管理它们使用计算机内存的方式<ul><li>有些语言有垃圾收集机制,在程序运行时,它们会不断寻找不再使用的内存</li><li>在其它语言中,程序员必须显示的分配和释放内存(不包括 js 吧 😋)</li></ul></li><li>Rust 采用了第三种方式:<ul><li>内存是通过一个所有权系统来管理的,其中包含一组编译器在编译时检查的规则</li><li>当程序运行时,所有权特性不会减慢程序的运行速度</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="411-stack-vs-heap">4.1.1 Stack vs Heap<a href="#411-stack-vs-heap" class="hash-link" aria-label="Direct link to 4.1.1 Stack vs Heap" title="Direct link to 4.1.1 Stack vs Heap">​</a></h4><p>栈内存 vs 堆内存</p><ul><li>在像 Rust 这样的系统级编程语言里,一个值是在 stack 上还是在 heap 上堆语言的行为和你为什么要做某些决定时有更大的影响的</li><li>在你的代码运行的时候,Stack 和 Heap 都是你可用的内存,但是它们的解构很不相同.</li></ul><p><strong>存储数据</strong></p><ul><li><p>Stack 按值的接受顺序来存储,按相反的顺序将它们移除(后进先出,LIFO)</p><ul><li>添加数据叫做压入栈</li><li>移除数据叫做弹出栈</li></ul></li><li><p>所有存储在 Stack 上的数据必须拥有已知的固定的大小</p><ul><li>编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在 heap 上</li></ul></li><li><p>Heap 内存组织性差一些</p><ul><li>当你把数据放入 heap 时,你会请求一定数量的空间</li><li>操作系统在 heap 里找到一块足够大的空间,把它标记为在用,并返回一个指针,也就是这个空间的地址</li><li>这个过程叫做在 heap 上进行分配,有时候仅仅称为分配</li></ul></li><li><p>把值压在 stack 上不叫分配</p></li><li><p>因为指针是已知固定大小的,可以把指针存放在 stack 上.</p><ul><li>当如果想要实际数据,你必须使用指针来定位</li></ul></li><li><p>把数据压倒 stack 上要比在 heap 上分配快得多</p><ul><li>因为操作系统不需要寻找用来存储新数据的空间,那个位置永远都在 stack 的顶端</li></ul></li></ul><p><strong>访问数据</strong></p><ul><li>访问 heap 中的数据要比访问 stack 中的数据慢,因为需要通过指针才能找到 heap 中的数据<ul><li>对于现代的处理器来说,由于缓存的缘故,如果指令在内存中跳转的次数越少,那么速度就越快</li></ul></li><li>如果数据存放的距离比较近,那么处理器的处理速度就会更快以下(stack)上</li><li>如果数据之间的距离比较远,那么处理速度就会慢一些(heap)上<ul><li>在 heap 上分配大量的空间也是需要时间的</li></ul></li></ul><p><strong>函数调用</strong></p><ul><li>当你的代码调用函数时,值被传入到函数(也包括指向 heap 的指针).函数本地的变量被压到 stack 上. 当函数结束后,这些值会从 stack 上弹出</li></ul><p><strong>所有权存在的原因</strong></p><ul><li>所有权解决的问题:<ul><li>跟踪代码的哪些部分正在使用 heap 的哪些数据</li><li>最小化 heap 上的重复数据量</li><li>清理 heap 上从未使用的数据以避免空间不足</li></ul></li><li>一旦你懂得了所有权,那么就不需要经常去想 stack 或 heap 了</li><li>但是直到管理 heap 数据是所有权存在的原因,这有助于解释它为什么会这样工作</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="412-所有权规则内存与分配">4.1.2 所有权规则、内存与分配<a href="#412-所有权规则内存与分配" class="hash-link" aria-label="Direct link to 4.1.2 所有权规则、内存与分配" title="Direct link to 4.1.2 所有权规则、内存与分配">​</a></h4><p><strong>所有权规则</strong></p><ul><li>每个值都有一个变量，这个变量是该值的所有者</li><li>每个值同时只能有一个所有者</li><li>当所有者超出作用域(scope)时，该值将被删除</li></ul><p><strong>变量作用域</strong></p><ul><li>Scope 就是程序中一个项目的有效范围</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // s 不可用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;hello&quot;; // s 可用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     // 可以对 s 进行相关操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Hello, world!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} // s 作用域到此结束，s 不再可用</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>String 类型</strong></p><ul><li>String 比那些基础标量数据类型更加复杂</li><li>字符串字面值：程序里手写的那些字符串值。它们是不可变的</li><li>Rust 还有第二种字符串类型：String<ul><li>在 heap 上分配。能够存储在编译时未知数量
<strong>创建 String 类型的值</strong></li><li>可以使用 from 函数从字符串字面值创建出 String 类型</li><li>let s = String::from(&quot;hello &quot;)</li><li>这类字符串是可以被修改的</li><li>为什么 String 类型的值可以修改，而字符串字面值却不能修改<ul><li>因为它们处理内存的方式不同</li></ul></li></ul></li></ul><p><strong>内存和分配</strong></p><ul><li><p>字符串字面值，在编译时就知道它的内容，其文本内容直接被硬编码到最终的可执行文件里</p><ul><li>速度快、高效。是因为其不可变性。</li></ul></li><li><p>String 类型，为了支持可变性，需要在 heap 上分配内存来保存编译时未知的文本内容：</p><ul><li>操作系统必须在运行时来请求内存<ul><li>这步通过调用 String::from 来实现</li></ul></li><li>当用完 String 之后，需要使用某种方式将内存返回给操作系统<ul><li>这步，在拥有 GC 的语言中，GC 会跟踪并清理</li><li>没有 GC，就需要我们去识别内存何时不再使用，并调用代码将它返回<ul><li>如果忘了，那就浪费内存</li><li>如果提前做了，变量就会非法</li><li>如果做了两次，也是 Bug，必须一次分配对应一次释放</li></ul></li></ul></li></ul></li><li><p>Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统</p></li><li><p>drop 函数</p></li></ul><p><strong>变量和数据交互的方式：移动（Move）</strong></p><ul><li>多个变量可以与同一个数据使用一种独特的方式来交互</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let y = x;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>整数时已知且固定大小的简单的值，这两个 5 被压倒了 stack 中</li></ul><p><strong>String 版本</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let s2 = s1;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><p>一个 String 由 3 部分组成</p><ul><li>一个指向存放字符串内容的内存的指针</li><li>一个长度</li><li>一个容量</li></ul></li><li><p>上面这些东西放在 stack 上。</p></li><li><p>存放字符串内容的部分在 heap 上</p></li><li><p>长度 len，就是存放字符串内容所需要的字节数</p></li><li><p>容量 capacity 是指 String 从操作系统总共获得内存的总字节数</p></li><li><p>当把 s1 赋给 s2，String 的数据被复制了一份</p><ul><li>在 stack 上复制了一份指针、长度、容量</li><li>并没有复制指针所指向的 heap 上的数据</li></ul></li><li><p>当变量离开作用域时，Rust 会自动调用 drop 函数，并将变量使用的 heap 内存释放</p></li><li><p>当 s1、s2 离开作用域时，它们都会尝试释放相同的内存：</p><ul><li>二次释放（double free）bug</li></ul></li><li><p>为了保证内存安全：</p><ul><li>Rust 没有尝试复制被分配的内存</li><li>Rust 让 s1 失效<ul><li>当 s1 离开作用域的时候，Rust 不需要释放任何东西</li></ul></li></ul></li><li><p>试试看当 s2 创建后再使用 s1 是什么效果</p></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s1);// 报错 s1 已经失效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>浅拷贝（shallow copy）</li><li>深拷贝（deep copy）</li><li>你也许会将复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以我们用一个新的术语：移动（Move）</li><li>隐含的一个设计原则：Rust 不会自动创建数据的深拷贝<ul><li>就运行时性能而言，任何自动赋值的操作都是廉价的</li></ul></li></ul><p><strong>变量和数据交互的方式：克隆（Clone）</strong></p><ul><li>如果真想堆 heap 上的 String 数据进行深度拷贝，而不仅仅是 stack 上的数据，可以使用 clone 方法</li></ul><p><strong>Stack 上的数据：复制</strong></p><ul><li>Copy trait，可以用于像整数这样完全存放再 stack 上面的类型</li><li>如果一个类型实现了 Copy 这个 trait，那么旧的变量在赋值后仍然可用</li><li>如果一个类型或者该类型的一部分实现 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了</li></ul><p><strong>一些拥有 Copy trait 的类型</strong></p><ul><li>任何简单标量的组合类型都可以是 Copy 的</li><li>任何需要分配内存或某种资源的都不是 Copy 的</li><li>一些拥有 Copy trait 的类型：<ul><li>所有的整数类型，例如 u32</li><li>bool</li><li>char</li><li>所有的浮点类型，例如 f64</li><li>Tuple（元组），如果其所有的字段都是 Copy 的<ul><li>(i32,i32) 是</li><li>(i32,String) 不是</li></ul></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="413-所有权与函数">4.1.3 所有权与函数<a href="#413-所有权与函数" class="hash-link" aria-label="Direct link to 4.1.3 所有权与函数" title="Direct link to 4.1.3 所有权与函数">​</a></h3><ul><li>在语义上，将值传递给函数和把值赋给变量是类似的：<ul><li>将值传递给函数将发生移动或复制</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;Hello World&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    take_ownership(s);// 函数执行后 s 就无效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    makes_copy(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;x:{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn take_ownership(some_string: String) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, some_string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn makes_copy(some_number: i32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, some_number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>返回值与作用域</strong></p><ul><li>函数在返回值的过程中同样也会发生所有权的转移</li><li>一个变量的所有权总是遵循同样的模式：<ul><li>把一个值赋给其它变量时就会发生移动</li><li>当一个包含 heap 数据的变量离开作用域时，它的值就会被 drop 函数清理，除非数据的所有权移动到另一个变量上</li></ul></li></ul><p><strong>如何让函数使用某个值，但不获得其所有权？</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (s2, len) = calculate_length(s1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The length of &#x27;{}&#x27; is {}.&quot;, s2, len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn calculate_length(s: String) -&gt; (String, usize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let length = s.len();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (s, length)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="42-引用与借用">4.2 引用与借用<a href="#42-引用与借用" class="hash-link" aria-label="Direct link to 4.2 引用与借用" title="Direct link to 4.2 引用与借用">​</a></h2><p><strong>例子</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;Hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = calculate_length(&amp;s1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The length of &#x27;{}&#x27; is {}&quot;, s1, len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn calculate_length(s: &amp;String) -&gt; usize {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.len()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>参数的类型时&amp;String 而不是 String</li><li>&amp;符号就表示引用：允许你引用某些值而不取得其所有权</li></ul><p><strong>借用</strong></p><ul><li>我们把引用作为函数参数这个行为叫做借用</li><li>我们不能修改借用的东西</li><li>和变量一样，默认是不可变的</li></ul><p><strong>可变引用</strong></p><ul><li>可变引用有一个重要的限制：在特定作用域内，堆某一块数据，只能由一个可变的引用。<ul><li>这样做的好处是可在编译时防止数据竞争</li></ul></li><li>以下三种行为下会发生数据竞争：<ul><li>两个或多个指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有使用任何机制来同步对数据的访问</li></ul></li><li>可以通过创建新的作用域，来允许非同时的创建多个可变引 用（例子）</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;Hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = &amp;mut s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = &amp;mut s;// 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The length of &#x27;{}&#x27; is {}.&quot;, s1, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;Hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s1 = &amp;mut s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = &amp;mut s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>另一个限制</strong></p><ul><li>不可以同时拥有一个可变引用和一个不变引用</li><li>多个不变的引用是可行的</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;Hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r1 = &amp;s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r2 = &amp;s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = &amp;mut s;// 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{} {} {}&quot;, r1, r2, s1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="43-切片">4.3 切片<a href="#43-切片" class="hash-link" aria-label="Direct link to 4.3 切片" title="Direct link to 4.3 切片">​</a></h2><ul><li>Rust 的另一种不持有所有权的数据类型：切片（slice）</li><li>一道题，编写一个函数：<ul><li>它接收字符串作为参数</li><li>返回它在这个字符串里找到的第一个的那次</li><li>如果函数没找到任何控股个，那么整个字符串就被返回</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;Hello world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let word_index = fitst_world(&amp;s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, word_index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn fitst_world(s: &amp;String) -&gt; usize {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let bytes = s.as_bytes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i, &amp;item) in bytes.iter().enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if item == b&#x27; &#x27; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.len()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="字符串切片">字符串切片<a href="#字符串切片" class="hash-link" aria-label="Direct link to 字符串切片" title="Direct link to 字符串切片">​</a></h3><ul><li>字符串切片是指字符串中一部分内容的引用</li><li>形式：<!-- -->[开始索引..结束索引]<ul><li>开始索引就是切片起始位置的索引值</li><li>结束索引就是切片终止位置的下一个索引值</li></ul></li></ul><p><strong>注意</strong></p><ul><li>字符串切片的返回索引必须发生在有效的 UTF-8 字符边界内。</li><li>如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;Hello World&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let hello = &amp;s[0..5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let world = &amp;s[6..11];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let hello = &amp;s[..5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let world = &amp;s[6..];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let world = &amp;s[6..s.len()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // println!(&quot;{},{}&quot;, hello, world);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let whole = &amp;s[0..s.len()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let whole = &amp;s[..];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, whole);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>使用字符串切片重写例子</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;Hello world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let word_index = fitst_world(&amp;s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, word_index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn fitst_world(s: &amp;String) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let bytes = s.as_bytes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i, &amp;item) in bytes.iter().enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if item == b&#x27; &#x27; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &amp;s[..i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;s[..]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="字符串字面值是切片">字符串字面值是切片<a href="#字符串字面值是切片" class="hash-link" aria-label="Direct link to 字符串字面值是切片" title="Direct link to 字符串字面值是切片">​</a></h4><ul><li>字符串字面值被直接存储在二进制程序中</li><li>let s = &quot;Hello World&quot;</li><li>变量 s 的类型是&amp;str，他是一个指向二进制程序特定位置的切片<ul><li>&amp;str 是不可变引用，所以字符串字面值也是不可变的</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="将字符串切片作为参数传递">将字符串切片作为参数传递<a href="#将字符串切片作为参数传递" class="hash-link" aria-label="Direct link to 将字符串切片作为参数传递" title="Direct link to 将字符串切片作为参数传递">​</a></h4><ul><li>fn first_word(s:&amp;String)-&gt;&amp;str{}</li><li>有经验的 Rust 开发者会采用&amp;str 作为参数类型，因为这样就可以同时接收 String 和&amp;str 类型的参数了：</li><li>fn first_world(s:&amp;str)-&gt;&amp;str {}<ul><li>使用字符串切片，直接调用该函数</li><li>使用 String，可以创建一个完成 String 切片来调用该函数</li></ul></li><li>定义函数时使用字符串切片来代替字符串引用会使我们的 API 更加通用，且不会损失任何功能。</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let my_string = String::from(&quot;Hello World&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let word_index = first_world(&amp;my_string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let my_string_literal = &quot;hello world&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let word_index = first_world(my_string_literal);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn first_world(s: &amp;str) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let bytes = s.as_bytes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i, &amp;item) in bytes.iter().enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if item == b&#x27; &#x27; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &amp;s[..i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;s[..]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="其它类型的切片">其它类型的切片<a href="#其它类型的切片" class="hash-link" aria-label="Direct link to 其它类型的切片" title="Direct link to 其它类型的切片">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = [1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let slice = &amp;a[1..3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5struct">5.struct<a href="#5struct" class="hash-link" aria-label="Direct link to 5.struct" title="Direct link to 5.struct">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-定义并实例化-struct">5.1 定义并实例化 struct<a href="#51-定义并实例化-struct" class="hash-link" aria-label="Direct link to 5.1 定义并实例化 struct" title="Direct link to 5.1 定义并实例化 struct">​</a></h3><p><strong>什么是 struct</strong></p><ul><li>struct，结构体<ul><li>自定义的数据类型</li><li>为相关联的值命名，打包 =&gt; 有意义的组合</li></ul></li></ul><p><strong>定义 struct</strong></p><ul><li>使用 <strong>struct</strong> 关键字，并未整个 struct 命名</li><li>在花括号内，为所有<code>字段（Field）</code>定义名称和类型</li><li>例如：</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    username: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    email: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sign_in_count: u64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    active: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>实例化 struct</strong></p><ul><li>想要使用 struct，需要创建 struct 的实例<ul><li>为每个字段指定具体值</li><li>无需按声明的顺序进行指定</li></ul></li><li>例子</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let user1 = User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email: String::from(&quot;chovrio@.....&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: String::from(&quot;chovrio&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sign_in_count: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        active: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-struct-中的例子">5.2 struct 中的例子<a href="#52-struct-中的例子" class="hash-link" aria-label="Direct link to 5.2 struct 中的例子" title="Direct link to 5.2 struct 中的例子">​</a></h3><p><strong>取得 struct 里面的某个值</strong></p><ul><li>使用点标记法</li><li>user1.email = String::from(&quot;<a href="mailto:Autumn@..." target="_blank" rel="noopener noreferrer">Autumn@...</a>&quot;)</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let mut user1 = User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email: String::from(&quot;chovrio@.....&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: String::from(&quot;chovrio&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sign_in_count: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        active: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的</li></ul><p><strong>struct 作为函数的返回值</strong></p><p>字段同名可以简化</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn build_user(email: String, username: String) -&gt; User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        active: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sign_in_count: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>struct 更新语法</strong></p><ul><li>当你想要基于某个 struct 实例来创建一个新实例的时候，可以使用 struct 更新语法：</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let user2 = User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email: String::from(&quot;AAAA&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: String::from(&quot;BBB&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ..user1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Tuple struct</strong></p><ul><li>可定义类似 tuple 的 struct，叫做 tuple struct<ul><li>Tuple struct 整体有个名，但里面的元素没有名</li><li>适用：想给整个 tuple 起名，并让它不同于其它 tuple，而且又不需要给每个元素其起名</li></ul></li><li>定义 tuple struct：使用 struct 关键字，后边是名字，以及里面元素的类型</li><li>black 和 origin 是不同的类型，是不同 tuple struct 的实例。</li></ul><p><strong>Unit-Like Struct（没有任何字段）</strong></p><ul><li>可以定义没有任何字段的 struct，叫做 Unit-Like struct（因为与()，单元类型类似）</li><li>适用于需要在某个类型上实现某个 trait，但是在里面有没有想要存储的数据</li></ul><p><strong>struct 数据的所有权</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct User1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    username: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    email: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sign_in_count: u64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    active: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>这里的字段使用了 String 而不是&amp;str：<ul><li>该 struct 实例拥有其所有的数据</li><li>只要 struct 实例是有效的，那么里面的字段也是有效的</li></ul></li><li>struct 里也可以存放引用，但这需要使用生命周期 -生命周期保证只要 struct 实例是有效的，那么里面的引用也是有效的。</li><li>如果 struct 里面存储引用，而不使用生命周期，就会报错</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    username: &amp;str,// 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    email: &amp;str,// 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sign_in_count: u64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    active: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Hello World&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let user1 = User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email: &quot;aaa&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: &quot;bbb&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        active: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sign_in_count: 100,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>计算矩形面积例子</strong></p><p><strong>普通版本</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let w = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let l = 50;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, area(w, l));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn area(width: u32, length: u32) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    width * length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>元组版本</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let rect = (30, 50);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, area(rect));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn area(dim: (u32, u32)) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dim.0 * dim.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>结构体版本</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    width: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    length: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let rect = Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        width: 30,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        length: 50,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, area(&amp;rect));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn area(rect: &amp;Rectangle) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rect.width * rect.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-struct-的方法">5.3 struct 的方法<a href="#53-struct-的方法" class="hash-link" aria-label="Direct link to 5.3 struct 的方法" title="Direct link to 5.3 struct 的方法">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="531-定义方法">5.3.1 定义方法<a href="#531-定义方法" class="hash-link" aria-label="Direct link to 5.3.1 定义方法" title="Direct link to 5.3.1 定义方法">​</a></h4><ul><li>方法和函数类似：fn 关键字、名称、参数、返回值</li><li>方法与函数不同之处<ul><li>方法是在 struct（或 enum、frait 对象）的上下文中定义</li><li>第一个参数是 self，表示方法被调用的 struct 实例</li></ul></li><li>在 impl 块里定义方法</li><li>方法的第一个参数可以是&amp;self，也可以获得其所有权或可变借用。和其它参数一样。</li><li>更良好的代码组织</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    width: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    length: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn area(&amp;self) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.width * self.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let rect = Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        width: 30,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        length: 50,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, rect.area());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="532-方法调用的运算符">5.3.2 方法调用的运算符<a href="#532-方法调用的运算符" class="hash-link" aria-label="Direct link to 5.3.2 方法调用的运算符" title="Direct link to 5.3.2 方法调用的运算符">​</a></h4><ul><li>C/C++：object-&gt;something()和(<!-- -->*<!-- -->object.something()一样</li><li>Rust 没有 -&gt; 运算符</li><li>Rust 会自动引用或解引用<ul><li>在调用方法时，Rust 根据情况自动添加&amp;、&amp;mut 或<!-- -->*<!-- -->，以便 object 可以匹配方法的签名。</li></ul></li><li>下面两行代码效果相同：<ul><li>p1.distance(&amp;p2);</li><li>(&amp;p1).distance(&amp;p2)</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="533-方法参数">5.3.3 方法参数<a href="#533-方法参数" class="hash-link" aria-label="Direct link to 5.3.3 方法参数" title="Direct link to 5.3.3 方法参数">​</a></h4><ul><li>方法可以有多个参数</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   width: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   length: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self.width &gt; other.width &amp;&amp; self.length &gt; other.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let rect1 = Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       width: 30,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       length: 50,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let rect2 = Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       width: 10,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       length: 40,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let rect3 = Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       width: 35,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       length: 55,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;{}&quot;, rect1.can_hold(&amp;rect2)); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;{}&quot;, rect2.can_hold(&amp;rect3)); // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="534-关联函数">5.3.4 关联函数<a href="#534-关联函数" class="hash-link" aria-label="Direct link to 5.3.4 关联函数" title="Direct link to 5.3.4 关联函数">​</a></h4><ul><li>可以在 impl 块里定义不把 self 作为第一个参数的函数，它们叫关联函数（不叫方法）<ul><li>例如：String::from()</li></ul></li><li>关联函数通常用于构造器（例子）</li><li>::符号<ul><li>关联函数</li><li>模块创建的命名空间</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="535-多个-impl-块">5.3.5 多个 impl 块<a href="#535-多个-impl-块" class="hash-link" aria-label="Direct link to 5.3.5 多个 impl 块" title="Direct link to 5.3.5 多个 impl 块">​</a></h4><ul><li>每个 struct 允许拥有多个 impl 块（例子）</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6枚举与模式匹配">6.枚举与模式匹配<a href="#6枚举与模式匹配" class="hash-link" aria-label="Direct link to 6.枚举与模式匹配" title="Direct link to 6.枚举与模式匹配">​</a></h2><ul><li>枚举允许我们列举所有可能的值来定义一个类型</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="61-定义枚举">6.1 定义枚举<a href="#61-定义枚举" class="hash-link" aria-label="Direct link to 6.1 定义枚举" title="Direct link to 6.1 定义枚举">​</a></h3><ul><li>IP 地址：IPv4、IPv6</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum ip_addrkind {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  V4,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  V6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="611-枚举值">6.1.1 枚举值<a href="#611-枚举值" class="hash-link" aria-label="Direct link to 6.1.1 枚举值" title="Direct link to 6.1.1 枚举值">​</a></h4><ul><li>例子：</li><li>let four = ip_addrkind::V4;</li><li>let six = ip_addrkind::V6;</li></ul><p><strong>将数据附加到枚举的变体中</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum IpAddr {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  V4(String),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  V6(String),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>优点：<ul><li>不需要额外使用 struct</li><li>每个变体可以拥有不同的类型以及关联的数据量</li></ul></li><li>例如：</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum IpAddrKind  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  V4(u8,u8,u8,u8),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  V6(String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="612-标准库中的-ipaddr">6.1.2 标准库中的 IpAddr<a href="#612-标准库中的-ipaddr" class="hash-link" aria-label="Direct link to 6.1.2 标准库中的 IpAddr" title="Direct link to 6.1.2 标准库中的 IpAddr">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Ipv4Addr {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // --snip--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Ipv6Addr {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // --snip--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum IpAddr {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V4(Ipv4Addr),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V6(Ipv6Addr),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Message {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Quit,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Move { x: i32, y: i32 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Write(String),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ChangeColor(i32, i32, i32),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let q = Message::Quit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m = Message::Move { x: 12, y: 24 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let w = Message::Write(String::from(&quot;Hello&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = Message::ChangeColor(0, 255, 255);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="613-为枚举定义方法">6.1.3 为枚举定义方法<a href="#613-为枚举定义方法" class="hash-link" aria-label="Direct link to 6.1.3 为枚举定义方法" title="Direct link to 6.1.3 为枚举定义方法">​</a></h3><p>同样使用 <code>impl</code></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Message {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn call(&amp;self) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="62-option-枚举">6.2 Option 枚举<a href="#62-option-枚举" class="hash-link" aria-label="Direct link to 6.2 Option 枚举" title="Direct link to 6.2 Option 枚举">​</a></h3><ul><li>定义于标准库中</li><li>在 Prelude（预导入模块）中</li><li>描述了：某个值可能存在（某种类型）或不存在的情况</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="621-rust-没有-null">6.2.1 Rust 没有 Null<a href="#621-rust-没有-null" class="hash-link" aria-label="Direct link to 6.2.1 Rust 没有 Null" title="Direct link to 6.2.1 Rust 没有 Null">​</a></h4><ul><li>其它语言中：<ul><li>Null 是一个值，它表示“没有值”</li><li>一个变量可以处于两种状态：空值（null）、非空</li></ul></li><li>Null 引用：Billion Dollar Mistake</li><li>Null 的问题在于：当你尝试使用非 Null 值那样使用 Null 值的时候，就会引起某种错误</li><li>Null 的概念还是有用的：因某种原因而变为无效或缺失的值</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="622-rust-中类似-null-概念的枚举---optiont">6.2.2 Rust 中类似 Null 概念的枚举 - <code>Option&lt;T&gt;</code><a href="#622-rust-中类似-null-概念的枚举---optiont" class="hash-link" aria-label="Direct link to 622-rust-中类似-null-概念的枚举---optiont" title="Direct link to 622-rust-中类似-null-概念的枚举---optiont">​</a></h4><ul><li>标准库中的定义</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum Option&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Some(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><p>它包含在 Prelude（预导入模块）中。可以直接使用：</p><ul><li><code>Option&lt;T&gt;</code></li><li>Some(T)</li><li>None</li></ul></li><li><p>例子</p></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let some_number = Some(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let some_string = Some(&quot;A String&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let absent_number: Option&lt;i32&gt; = None;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="optiont比-null-好在哪"><code>Option&lt;T&gt;</code>比 Null 好在哪？<a href="#optiont比-null-好在哪" class="hash-link" aria-label="Direct link to optiont比-null-好在哪" title="Direct link to optiont比-null-好在哪">​</a></h4><ul><li><code>Option&lt;T&gt;</code>和<code>T</code>是不同的类型，不可以把<code>Option&lt;T&gt;</code>直接当成<code>T</code></li><li>若想使用<code>Option&lt;T&gt;</code>中的<code>T</code>，必须将它转为<code>T</code></li><li>而在 C#中：<ul><li>string a = null;</li><li>string b = a + &quot;123456&quot;;</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="63-控制流运算符---match">6.3 控制流运算符 - match<a href="#63-控制流运算符---match" class="hash-link" aria-label="Direct link to 6.3 控制流运算符 - match" title="Direct link to 6.3 控制流运算符 - match">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="631-强大的控制流运算符---match">6.3.1 强大的控制流运算符 - match<a href="#631-强大的控制流运算符---match" class="hash-link" aria-label="Direct link to 6.3.1 强大的控制流运算符 - match" title="Direct link to 6.3.1 强大的控制流运算符 - match">​</a></h4><ul><li>允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码</li><li>模式可以是字面值、变量、通配符...</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="632-绑定值的模式">6.3.2 绑定值的模式<a href="#632-绑定值的模式" class="hash-link" aria-label="Direct link to 6.3.2 绑定值的模式" title="Direct link to 6.3.2 绑定值的模式">​</a></h4><ul><li>匹配的分支可以绑定到被匹配对象的部分值<ul><li>因此，可以从 enum 变体中提取值</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum UsState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Alabame,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Alaska,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Coin {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Penny,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Nickel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Dime,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Quarter(UsState),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn value_in_cents(coin: Coin) -&gt; u8 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match coin {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Coin::Penny =&gt; 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Coin::Nickel =&gt; 5,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Coin::Dime =&gt; 10,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Coin::Quarter(state) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;State quarter from {:?}&quot;, state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = Coin::Quarter(UsState::Alaska);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, value_in_cents(c));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="633-匹配optiont">6.3.3 匹配<code>Option&lt;T&gt;</code><a href="#633-匹配optiont" class="hash-link" aria-label="Direct link to 633-匹配optiont" title="Direct link to 633-匹配optiont">​</a></h4><p><strong>注意 match 匹配必须穷举所有的可能</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let five = Some(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let six = plus_one(five);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let none = plus_one(None);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match x {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(i) =&gt; Some(i + 1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="match_通配符">match<code>_</code>通配符<a href="#match_通配符" class="hash-link" aria-label="Direct link to match_通配符" title="Direct link to match_通配符">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = 0u8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match v {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1 =&gt; println!(&quot;one&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3 =&gt; println!(&quot;three&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        5 =&gt; println!(&quot;five&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; (),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="64-if-let">6.4 if let<a href="#64-if-let" class="hash-link" aria-label="Direct link to 6.4 if let" title="Direct link to 6.4 if let">​</a></h3><ul><li>处理只关心一种匹配而忽略其它匹配的情况</li><li>更少的代码，更少的缩进，更少的模板代码</li><li>放弃了穷举的可能</li><li>可以把 if let 看作是 match 的语法糖</li><li>搭配 else</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = Some(0u8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match v {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(3) =&gt; println!(&quot;three&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; println!(&quot;others&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Some(3) = v {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;three&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;others&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7packagecratemodule">7.Package，Crate，Module<a href="#7packagecratemodule" class="hash-link" aria-label="Direct link to 7.Package，Crate，Module" title="Direct link to 7.Package，Crate，Module">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="71-packagecrate定义-module">7.1 Package、Crate、定义 Module<a href="#71-packagecrate定义-module" class="hash-link" aria-label="Direct link to 7.1 Package、Crate、定义 Module" title="Direct link to 7.1 Package、Crate、定义 Module">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="711-rust-的代码组织">7.1.1 Rust 的代码组织<a href="#711-rust-的代码组织" class="hash-link" aria-label="Direct link to 7.1.1 Rust 的代码组织" title="Direct link to 7.1.1 Rust 的代码组织">​</a></h4><ul><li>代码组织主要包括：<ul><li>哪些细节可以暴露，哪些细节是私有的</li><li>作用域内哪些名称有效</li><li>...</li></ul></li><li>模块系统：<ul><li><code>Package（包）</code>：Cargo 的特性，让你构建、测试、共享 crate</li><li><code>Crate（单元包）</code>：一个模块树，它可产生一个 library 或可执行文件</li><li><code>Module（模块）</code>、use：让你控制代码的组织、作用域、私有路径</li><li><code>Path（路径）</code>：为 struct、function 或 module 等项命名的方式</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="712-package-和-crate">7.1.2 Package 和 Crate<a href="#712-package-和-crate" class="hash-link" aria-label="Direct link to 7.1.2 Package 和 Crate" title="Direct link to 7.1.2 Package 和 Crate">​</a></h4><ul><li><strong>Crate</strong> 的类型：<ul><li><strong>binary</strong>（二进制）</li><li><strong>library</strong>（库）</li></ul></li><li><strong>Crate Root</strong>：<ul><li>是源代码文件</li><li>Rust 编译器从这里开始，组成你的 Crate 的根 Module</li></ul></li><li>一个<strong>Package</strong>：<ul><li>包含 1 个 Cargo.toml，它描述了如何构建这些 Crates</li><li>只能包含 0-1 个 library crate</li><li>可以包含任意数量的 binary crate</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="713-cargo-的惯例">7.1.3 Cargo 的惯例<a href="#713-cargo-的惯例" class="hash-link" aria-label="Direct link to 7.1.3 Cargo 的惯例" title="Direct link to 7.1.3 Cargo 的惯例">​</a></h4><ul><li>src/main.rs:<ul><li>binary crate 的 crate root</li><li>crate 名与 package 名相同</li></ul></li><li>src/lib.rs：<ul><li>package 包含一个 library crate</li><li>library crate 的 crate root</li><li>crate 名与 package 名相同</li></ul></li><li>Cargo 把 crate root 文件交给 rustc 来构建 library 或 binary</li><li>一个 Package 可以同时包含 src/main.rs 和 src/lib.rs<ul><li>一个 binary create，一个 library create</li><li>名称与 package 名相同</li></ul></li><li>一个 Package 可以有多个 binary crate：<ul><li>文件放在：src/bin</li><li>每个文件是单独的 binary crate</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="714-crate-的作用">7.1.4 Crate 的作用<a href="#714-crate-的作用" class="hash-link" aria-label="Direct link to 7.1.4 Crate 的作用" title="Direct link to 7.1.4 Crate 的作用">​</a></h4><ul><li>将相关功能组合到一个作用域内，便于在项目将进行共享<ul><li>防止冲突</li></ul></li><li>例如 rand crate，访问它的功能需要通过它的名字：rand</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="715-定义-module-来控制作用域和私有性">7.1.5 定义 module 来控制作用域和私有性<a href="#715-定义-module-来控制作用域和私有性" class="hash-link" aria-label="Direct link to 7.1.5 定义 module 来控制作用域和私有性" title="Direct link to 7.1.5 定义 module 来控制作用域和私有性">​</a></h4><ul><li>Module：<ul><li>在一个 crate 内，将代码进行分组</li><li>增加可读性，易于复用</li><li>控制项目（item）的私有性。public、private</li></ul></li><li>建立 module<ul><li>mod 关键字</li><li>可嵌套</li><li>可包含其它项（struct，enum，常量，trait，函数等）的定义</li></ul></li><li>src/main.rs 和 src/lib.rs 叫做 crate roots：<ul><li>这两个文件（任意一个）的内容形成了名为 crate 的模块，位于整个模块树的根部</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mod front_of_house {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mod hosting {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn add_to_waitlist() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn seat_at_table() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mod serving {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn take_order() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn serve_order() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn take_payment() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="72-路径">7.2 路径<a href="#72-路径" class="hash-link" aria-label="Direct link to 7.2 路径" title="Direct link to 7.2 路径">​</a></h3><ul><li>为了在 Rust 的模块中找到某个条目，需要使用<code>路径</code>。</li><li>路径的两种形式：<ul><li>绝对路径：从 crate root 开始，使用 crate 名或字面值 crate</li><li>相对路径：从当前模块开始，使用 self，super 或当前模块的标识符</li></ul></li><li>路径至少由一个标识符组成，标识符之间使用::。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="721-私有边界privacy-boundary">7.2.1 私有边界（privacy boundary）<a href="#721-私有边界privacy-boundary" class="hash-link" aria-label="Direct link to 7.2.1 私有边界（privacy boundary）" title="Direct link to 7.2.1 私有边界（privacy boundary）">​</a></h4><ul><li>模块不仅可以组织代码，还可以定义私有边界。</li><li>如果想把函数或 struct 等设为私有，可以将它放在某个模块中。</li><li>Rust 中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的</li><li>父级模块无法访问子模块中的私有条目</li><li>子模块里可以使用所有祖先模块中的条目</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="721-pub-关键字">7.2.1 pub 关键字<a href="#721-pub-关键字" class="hash-link" aria-label="Direct link to 7.2.1 pub 关键字" title="Direct link to 7.2.1 pub 关键字">​</a></h4><ul><li>使用 pub 关键字来将某些条目标记为公共的</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mod front_of_house {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub mod hosting {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn add_to_waitlist() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn eat_at_restaurant() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    crate::front_of_house::hosting::add_to_waitlist();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    front_of_house::hosting::add_to_waitlist();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="722-super-关键字">7.2.2 super 关键字<a href="#722-super-关键字" class="hash-link" aria-label="Direct link to 7.2.2 super 关键字" title="Direct link to 7.2.2 super 关键字">​</a></h4><ul><li><code>super</code>:用来访问父级模块路径中的内容，类似文件系统中的..</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn serve_order() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mod back_of_house {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use crate::cook_order;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fix_incorrect_order() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cook_order();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super::serve_order(); // 相对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        crate::serve_order(); // 绝对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn cook_order() {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="723-pub-struct-关键字">7.2.3 pub struct 关键字<a href="#723-pub-struct-关键字" class="hash-link" aria-label="Direct link to 7.2.3 pub struct 关键字" title="Direct link to 7.2.3 pub struct 关键字">​</a></h4><ul><li>pub 放在 struct 前：<ul><li>struct 是公共的</li><li>struct 的字段默认是私有的</li></ul></li><li>struct 的字段需要单独设置 pub 来变成共有</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mod back_of_house {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub struct BreakFast {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub toast: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        seasonal_fruit: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl BreakFast {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn summer(toast: &amp;str) -&gt; BreakFast {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BreakFast {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                toast: String::from(toast),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                seasonal_fruit: String::from(&quot;peaches&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn eat_at_restaurant() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut meal = back_of_house::BreakFast::summer(&quot;Rye&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    meal.toast= String::from(&quot;Wheat&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;I&#x27;d like {} toast please&quot;, meal.toast);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    meal.seasonal_fruit = String::from(&quot;blueberries&quot;);// 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="724-pub-enum">7.2.4 pub enum<a href="#724-pub-enum" class="hash-link" aria-label="Direct link to 7.2.4 pub enum" title="Direct link to 7.2.4 pub enum">​</a></h4><ul><li>pub 放在 enum 前 :<ul><li>enum 是<code>公共</code>的</li><li>enum 的变体也都是<code>公共</code>的</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="73-use-关键字">7.3 use 关键字<a href="#73-use-关键字" class="hash-link" aria-label="Direct link to 7.3 use 关键字" title="Direct link to 7.3 use 关键字">​</a></h3><ul><li>可以使用<code>use</code>关键字将路径导入到作用域内<ul><li>仍遵循私有性规则</li></ul></li><li>使用 use 来指定相对路径</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="731-use-的习惯用法">7.3.1 use 的习惯用法<a href="#731-use-的习惯用法" class="hash-link" aria-label="Direct link to 7.3.1 use 的习惯用法" title="Direct link to 7.3.1 use 的习惯用法">​</a></h4><ul><li>函数：将函数的父级模块引入作用域（指定到父级）</li><li>struct，enum，其它：指定完整路径（指定到本身）</li><li>同名条目：指定到父级</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="732-使用-pub-use-重新导入名称">7.3.2 使用 pub use 重新导入名称<a href="#732-使用-pub-use-重新导入名称" class="hash-link" aria-label="Direct link to 7.3.2 使用 pub use 重新导入名称" title="Direct link to 7.3.2 使用 pub use 重新导入名称">​</a></h4><ul><li>使用 use 将路径（名称）导入到作用域内后，该名称在此作用域内是<code>私有</code>的</li><li>pub use：重导出<ul><li>将条目引入作用域</li><li>该条目可以被外部代码引入到它们的作用域</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="733-使用外部包package">7.3.3 使用外部包（package）<a href="#733-使用外部包package" class="hash-link" aria-label="Direct link to 7.3.3 使用外部包（package）" title="Direct link to 7.3.3 使用外部包（package）">​</a></h4><ol><li>Cargo.toml 添加依赖的包（package）</li></ol><ul><li><a href="https://crates.io/" target="_blank" rel="noopener noreferrer">https://crates.io/</a></li></ul><ol start="2"><li>use 将特定条目引入作用域</li></ol><ul><li>标准库（std）也被当做外部包<ul><li>不需要修改 Cargo.toml 文件来包含 std</li><li>需要使用 use 将 std 中的特定条目引入当前作用域</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="734-使用嵌套路径清理大量的-use-语句">7.3.4 使用<code>嵌套路径</code>清理大量的 use 语句<a href="#734-使用嵌套路径清理大量的-use-语句" class="hash-link" aria-label="Direct link to 734-使用嵌套路径清理大量的-use-语句" title="Direct link to 734-使用嵌套路径清理大量的-use-语句">​</a></h4><ul><li>如果使用同一个包或模块下的多个条目（例子）</li><li>可以使用嵌套路径在同一行内将上述条目进行引入：<ul><li>路径相同的部分::{路径差异的部分}</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::cmp::Ordering;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{cmp::Ordering, io};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io::{self,Write}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="735-通配符">7.3.5 通配符<!-- -->*<a href="#735-通配符" class="hash-link" aria-label="Direct link to 735-通配符" title="Direct link to 735-通配符">​</a></h4><ul><li>使用<!-- -->*<!-- -->可以把路径中所有的公共条目都引入到作用域</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::*;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>注意：谨慎使用</li><li>引用场景：<ul><li>测试，将所有被测试代码引入 tests 模块</li><li>有时被用于预导入（prelude）模块</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="74-将模块拆分为不同文件">7.4 将模块拆分为不同文件<a href="#74-将模块拆分为不同文件" class="hash-link" aria-label="Direct link to 7.4 将模块拆分为不同文件" title="Direct link to 7.4 将模块拆分为不同文件">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="741-将模块内容移动到其它文件">7.4.1 将模块内容移动到其它文件<a href="#741-将模块内容移动到其它文件" class="hash-link" aria-label="Direct link to 7.4.1 将模块内容移动到其它文件" title="Direct link to 7.4.1 将模块内容移动到其它文件">​</a></h4><ul><li>模块定义时，如果模块名后边是“;”，而不是代码块：<ul><li>Rust 会从与模块同名的文件中加载内容</li><li>模块树的结构不会发生变化</li></ul></li><li>随着模块逐渐变大，该技术让你可以把模块的内容移动到其它文件中</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="8常用的集合">8.常用的集合<a href="#8常用的集合" class="hash-link" aria-label="Direct link to 8.常用的集合" title="Direct link to 8.常用的集合">​</a></h2><ul><li>Vector</li><li>String</li><li>HashMap</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="81-vector">8.1 Vector<a href="#81-vector" class="hash-link" aria-label="Direct link to 8.1 Vector" title="Direct link to 8.1 Vector">​</a></h3><ul><li><code>Vec&lt;T&gt;</code> 叫做 vector<ul><li>由标准库提供</li><li>可存储多个值</li><li>只能存储相同类型的数据</li><li>值在内存中连续存放</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="811-创建-vector">8.1.1 创建 Vector<a href="#811-创建-vector" class="hash-link" aria-label="Direct link to 8.1.1 创建 Vector" title="Direct link to 8.1.1 创建 Vector">​</a></h4><ul><li>Vec::new 函数</li><li><code> let v: Vec&lt;i32&gt; = Vec::new();</code></li><li>使用初始值创建 Vec &lt;T<!-- -->&gt;<!-- -->,使用 vec!宏<ul><li><code>let v = vec![1, 2, 3];</code></li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="812-删除-vector">8.1.2 删除 Vector<a href="#812-删除-vector" class="hash-link" aria-label="Direct link to 8.1.2 删除 Vector" title="Direct link to 8.1.2 删除 Vector">​</a></h4><ul><li>与任何其它 struct 一样，但 Vector 离开作用域后<ul><li>它就被清理掉了</li><li>它所有的元素也被清理掉了</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="813-读取-vector-的元素">8.1.3 读取 Vector 的元素<a href="#813-读取-vector-的元素" class="hash-link" aria-label="Direct link to 8.1.3 读取 Vector 的元素" title="Direct link to 8.1.3 读取 Vector 的元素">​</a></h4><ul><li><code>两种方式可以引用</code>Vector 里的值<ul><li>索引</li><li>get 方法</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let third: &amp;i32 = &amp;v[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The third element is {}&quot;, third);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match v.get(2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; println!(&quot;The is no third element&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="814-所有权和借用规则">8.1.4 所有权和借用规则<a href="#814-所有权和借用规则" class="hash-link" aria-label="Direct link to 8.1.4 所有权和借用规则" title="Direct link to 8.1.4 所有权和借用规则">​</a></h4><ul><li>不能在统一作用域内同时拥有可变和不可变引用</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v = vec![1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let first = &amp;v[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.push(6);// 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The first element is {}&quot;, first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="815-遍历-vector-中的值">8.1.5 遍历 Vector 中的值<a href="#815-遍历-vector-中的值" class="hash-link" aria-label="Direct link to 8.1.5 遍历 Vector 中的值" title="Direct link to 8.1.5 遍历 Vector 中的值">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v = vec![100, 32, 57];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in &amp;mut v {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // * 是取这个地址的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *i += 50;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="82-vector-例子">8.2 Vector-例子<a href="#82-vector-例子" class="hash-link" aria-label="Direct link to 8.2 Vector-例子" title="Direct link to 8.2 Vector-例子">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="821-使用-enum-来存储多种数据类型">8.2.1 使用 enum 来存储多种数据类型<a href="#821-使用-enum-来存储多种数据类型" class="hash-link" aria-label="Direct link to 8.2.1 使用 enum 来存储多种数据类型" title="Direct link to 8.2.1 使用 enum 来存储多种数据类型">​</a></h4><ul><li>Enum 的变体可以附加不同类型的数据</li><li>Enum 的变体定义在同一个 enum 类型下</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum SpreadsheetCell {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Int(i32),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Float(f64),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Text(String),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let row = vec![</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SpreadsheetCell::Int(3),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SpreadsheetCell::Float(10.12),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="83-string">8.3 String<a href="#83-string" class="hash-link" aria-label="Direct link to 8.3 String" title="Direct link to 8.3 String">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="831-rust-开发者经常会被字符串困扰的原因">8.3.1 Rust 开发者经常会被字符串困扰的原因<a href="#831-rust-开发者经常会被字符串困扰的原因" class="hash-link" aria-label="Direct link to 8.3.1 Rust 开发者经常会被字符串困扰的原因" title="Direct link to 8.3.1 Rust 开发者经常会被字符串困扰的原因">​</a></h4><ul><li>Rust 倾向于暴露可能的错误</li><li>字符串数据结构复杂</li><li>UTF-8</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="832-字符串是什么">8.3.2 字符串是什么<a href="#832-字符串是什么" class="hash-link" aria-label="Direct link to 8.3.2 字符串是什么" title="Direct link to 8.3.2 字符串是什么">​</a></h4><ul><li>Byte 的集合<ul><li>一些方法<ul><li>能将 byte 解析为文本</li></ul></li></ul></li><li>Rust 的<code>核心语言层面</code>,只有一个字符串类型:字符串切片<code>str</code>(或&amp;str)</li><li>字符串切片:对存储在其它地方 UTF-8 编码的字符串的引用<ul><li>字符串字面值:存储在二进制文件中,也是字符串切片</li></ul></li><li><code>String</code>类型:<ul><li>来自<code>标准库</code>而不是核心语言</li><li>可增长,可修改,可拥有</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="833-通常说的字符串是指">8.3.3 通常说的字符串是指?<a href="#833-通常说的字符串是指" class="hash-link" aria-label="Direct link to 8.3.3 通常说的字符串是指?" title="Direct link to 8.3.3 通常说的字符串是指?">​</a></h4><ul><li>String 和&amp;str<ul><li>标准库里用的多</li><li>UTF-8 编码</li></ul></li><li>本节课讲的主要是 String</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="834-其它类型的字符串">8.3.4 其它类型的字符串<a href="#834-其它类型的字符串" class="hash-link" aria-label="Direct link to 8.3.4 其它类型的字符串" title="Direct link to 8.3.4 其它类型的字符串">​</a></h4><ul><li>Rust 的标准库还包含了很多其它的字符串类型,例如:OsString,OsStr,CString,CStr<ul><li>String vs Str 后缀:拥有或借用的变体</li><li>可存储不同编码的文本或在内存中以不同的形式展示</li></ul></li><li>Library crate 针对存储字符串可提供更多的选项</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="835-创建一个新的字符串string">8.3.5 创建一个新的字符串(String)<a href="#835-创建一个新的字符串string" class="hash-link" aria-label="Direct link to 8.3.5 创建一个新的字符串(String)" title="Direct link to 8.3.5 创建一个新的字符串(String)">​</a></h4><ul><li>很多<code>Vec&lt;T&gt;</code>的操作都可以用于 String.</li><li>String::new()函数</li><li>使用初始值来创建 String:<ul><li>to_string()方法,可用于实现了 Display trait 的类型,包括字符串字面值(例子)</li><li>String::from()函数,从字面量创建 String(例子)</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let mut s = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let data = &quot;initial contents&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = data.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = &quot;initial contents&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;initial contents&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="836-更新-string">8.3.6 更新 String<a href="#836-更新-string" class="hash-link" aria-label="Direct link to 8.3.6 更新 String" title="Direct link to 8.3.6 更新 String">​</a></h4><ul><li>push_str()方法:把一个字符串切片附加到 String(例子)</li><li>push 方法:把单个字符附加到 String</li><li><ul><li>连接字符串</li></ul><ul><li>使用了类似这个签名的方法 fn add(slef,s:&amp;str) -&gt; { ... }<ul><li>标准库中的 add 方法使用了泛型</li><li>只能把&amp;str 添加到 String</li><li>解引用强制转换(deref coercion)</li></ul></li></ul></li><li>format!:连接多个字符串(例子)</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;foo&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;bar&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.push_str(&amp;s1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.push(&#x27;h&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = String::from(&quot;aaaaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = String::from(&quot;BBBBB&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = a + &amp;b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, c);// aaaaaBBBBB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, a); // 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;tic&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = String::from(&quot;tac&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s3 = String::from(&quot;toe&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let s3 = s1 + &quot;-&quot; + &amp;*s2 + &quot;-&quot; + &amp;s3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // println!(&quot;{}&quot;, s3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="837-对-string-按索引的形式进行访问">8.3.7 对 String 按索引的形式进行访问<a href="#837-对-string-按索引的形式进行访问" class="hash-link" aria-label="Direct link to 8.3.7 对 String 按索引的形式进行访问" title="Direct link to 8.3.7 对 String 按索引的形式进行访问">​</a></h4><ul><li>按索引语法访问 String 的某部分,会报错</li><li>Rust 的字符串不支持索引语法访问</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="838-string-类型的内部表示">8.3.8 String 类型的内部表示<a href="#838-string-类型的内部表示" class="hash-link" aria-label="Direct link to 8.3.8 String 类型的内部表示" title="Direct link to 8.3.8 String 类型的内部表示">​</a></h4><ul><li>String 是对<code>Vec&lt;u8&gt;</code>的包装</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="839-字节标量值字形簇">8.3.9 字节,标量值,字形簇<a href="#839-字节标量值字形簇" class="hash-link" aria-label="Direct link to 8.3.9 字节,标量值,字形簇" title="Direct link to 8.3.9 字节,标量值,字形簇">​</a></h4><p><strong>Bytes,Scalar,Grapheme Clusters</strong></p><ul><li>Rust 有三种看待字符串的方式:<ul><li>字节 bytes</li><li>标量值 chars</li><li>字形簇</li></ul></li><li>Rust 不允许对 String 进行索引的最后一个原因:<ul><li>索引操作应消耗一个 v 额产量时间(O(1))</li><li>而 String 无法保证:需要遍历所有内容,来确定由多少个合法的字符.</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8310-切割-string">8.3.10 切割 String<a href="#8310-切割-string" class="hash-link" aria-label="Direct link to 8.3.10 切割 String" title="Direct link to 8.3.10 切割 String">​</a></h4><ul><li>可以使用<code>[]</code>和<code>一个范围</code>来创建字符串的切片<ul><li>必须谨慎使用</li><li>如果切割时跨越了字符边界,程序就会 panic</li><li><code>(b1,b2),(b3,</code>b3)(b4,b5),(b7,b7)<ul><li>panic</li></ul></li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8311-遍历-string-的方法">8.3.11 遍历 String 的方法<a href="#8311-遍历-string-的方法" class="hash-link" aria-label="Direct link to 8.3.11 遍历 String 的方法" title="Direct link to 8.3.11 遍历 String 的方法">​</a></h4><ul><li>对于标量值:chars()方法</li><li>对于字节:bytes()方法</li><li>对于字形簇:很复杂,标准库未提供</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let w = &quot;哈哈哈&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for b in w.bytes() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for b in w.chars() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>String 不简单</strong></p><ul><li>Rust 选择将正确处理 String 数据作为所有 Rust 程序的默认行为<ul><li>程序员必须在处理 UTF-8 数据之前投入更多的精力</li></ul></li><li>可防止在开发后期处理涉及非 ASCII 字符的错误</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="84-hashmap">8.4 HashMap<a href="#84-hashmap" class="hash-link" aria-label="Direct link to 8.4 HashMap" title="Direct link to 8.4 HashMap">​</a></h3><p><strong><code>HashMap&lt;K,v&gt;</code></strong></p><ul><li>键值对的形式存储数据,一个键(Key)对应一个值(value)</li><li>Hash 函数:决定如何在内存中存放 K 和 V</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="841-创建-hashmap">8.4.1 创建 HashMap<a href="#841-创建-hashmap" class="hash-link" aria-label="Direct link to 8.4.1 创建 HashMap" title="Direct link to 8.4.1 创建 HashMap">​</a></h4><ul><li>创建空 HashMap:new()函数</li><li>添加数据:insert()方法</li><li>HashMap 用的较少,不在 prelude 中</li><li>标准库对其支持较少,没有内置的宏来创建 HashMap</li><li>数据存储在 heap 上</li><li>同构的, 一个 HashMap 中:<ul><li>所有的 K 必须是同一种类型</li><li>所有的 V 必须是同一种类型</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let mut scores: HashMap&lt;String, i32&gt; = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut scores = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    scores.insert(String::from(&quot;yellow&quot;), 50);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="842-另一种创建-hashmap-的方式collect-方法">8.4.2 另一种创建 HashMap 的方式:collect 方法<a href="#842-另一种创建-hashmap-的方式collect-方法" class="hash-link" aria-label="Direct link to 8.4.2 另一种创建 HashMap 的方式:collect 方法" title="Direct link to 8.4.2 另一种创建 HashMap 的方式:collect 方法">​</a></h4><ul><li>在元素类型为 Tuple 的 Vector 上使用 collect 方法,可以组建一个 HashMap:<ul><li>要求 Tuple 有两个值:一个作为 K,一个作为 V</li><li>collect 方法可以把数据整合成很多种集合类型,包括 HashMap<ul><li>返回值需要显式指明类型</li></ul></li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let intial_scores = vec![10, 50];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let scores: HashMap&lt;_, _&gt; = teams.iter().zip(intial_scores.iter()).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="843-hashmap-和所有权">8.4.3 HashMap 和所有权<a href="#843-hashmap-和所有权" class="hash-link" aria-label="Direct link to 8.4.3 HashMap 和所有权" title="Direct link to 8.4.3 HashMap 和所有权">​</a></h4><ul><li>对于实现了 Copy trait 的类型(例如 i32),值会被复制到 HashMap 中</li><li>对于拥有所有权的值(例如 String),值会被移动,所有权会转移给 HashMap</li><li>如果将值的引用插入到 HashMap,值本身不会移动</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let field_name = String::from(&quot;Favorite color&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let field_value = String::from(&quot;Blue&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut map = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用这种方式插不会丧失所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // map.insert(&amp;field_name, &amp;field_value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 丧失所有权,再次调用会报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.insert(field_name, field_value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // println!(&quot;{}&quot;, field_name); // 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="844-访问-hashmap-中的值">8.4.4 访问 HashMap 中的值<a href="#844-访问-hashmap-中的值" class="hash-link" aria-label="Direct link to 8.4.4 访问 HashMap 中的值" title="Direct link to 8.4.4 访问 HashMap 中的值">​</a></h4><ul><li>get 方法<ul><li>参数：K</li><li>返回：<code>Option&lt;&amp;V&gt;</code></li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut scores = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    scores.insert(String::from(&quot;Yellow&quot;), 50);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let team_name = String::from(&quot;Blue&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let score = scores.get(&amp;team_name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match score {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(s) =&gt; println!(&quot;{}&quot;, s),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; println!(&quot;team not exist&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="845-遍历-hashmap">8.4.5 遍历 HashMap<a href="#845-遍历-hashmap" class="hash-link" aria-label="Direct link to 8.4.5 遍历 HashMap" title="Direct link to 8.4.5 遍历 HashMap">​</a></h4><ul><li>for 循环</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">for (k, v) in &amp;scores {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}:{}&quot;, k, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="846-更新-hashmapkv">8.4.6 更新 HashMap&lt;K,V&gt;<a href="#846-更新-hashmapkv" class="hash-link" aria-label="Direct link to 8.4.6 更新 HashMap&lt;K,V&gt;" title="Direct link to 8.4.6 更新 HashMap&lt;K,V&gt;">​</a></h4><ul><li>HashMap 大小可变</li><li>每个 K 同时只能对应一个 V</li><li>更新 HashMap 中的数据：<ul><li>K 已经存在，对应一个 V<ul><li>替换现有的 V</li><li>保留现有的 V，忽略新的 V</li><li>合并现有的 V 和新的 V</li></ul></li></ul></li></ul><p><strong>替换现有的 V</strong></p><ul><li>如果向 HashMap 插入一对 KV，然后再插入同样的 K，但是不同的 V，那么原来的 V 会被替换掉</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut scores = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   scores.insert(String::from(&quot;Blue&quot;), 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   scores.insert(String::from(&quot;Blue&quot;), 25);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;{:?}&quot;, scores);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>只有 K 不对应任何值得情况下，才插入 V</strong></p><ul><li>entry 方法：检查指定得 K 是否对应一个 V<ul><li>参数为 K</li><li>返回 enum Entry：代表值是否存在</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="9错误处理">9.错误处理<a href="#9错误处理" class="hash-link" aria-label="Direct link to 9.错误处理" title="Direct link to 9.错误处理">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="91-panic-不可恢复的错误">9.1 panic! 不可恢复的错误<a href="#91-panic-不可恢复的错误" class="hash-link" aria-label="Direct link to 9.1 panic! 不可恢复的错误" title="Direct link to 9.1 panic! 不可恢复的错误">​</a></h3><p><strong>Rust 错误处理概述</strong></p><ul><li>Rust 的可靠性：错误处理<ul><li>大部分情况下：在编译时提示错误，并处理</li></ul></li><li>错误的分类：<ul><li>可回复<ul><li>例如文件未找到，可再次尝试</li></ul></li><li>不可恢复<ul><li>bug，例如访问的索引超出范围</li></ul></li><li>Rust 没有类似异常的机制<ul><li>可恢复错误：Result&lt;T,E<!-- -->&gt;</li><li>不可恢复：panic!宏</li></ul></li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="911-不可恢复的错误与-panic">9.1.1 不可恢复的错误与 panic!<a href="#911-不可恢复的错误与-panic" class="hash-link" aria-label="Direct link to 9.1.1 不可恢复的错误与 panic!" title="Direct link to 9.1.1 不可恢复的错误与 panic!">​</a></h4><ul><li>当 panic!宏执行<ul><li>你的程序会打印一个错误信息</li><li>展开(unwind)、清理调用栈（Stack）</li><li>退出程序</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="912-为应对-panic展开或终止abort调用栈">9.1.2 为应对 panic，展开或终止(abort)调用栈<a href="#912-为应对-panic展开或终止abort调用栈" class="hash-link" aria-label="Direct link to 9.1.2 为应对 panic，展开或终止(abort)调用栈" title="Direct link to 9.1.2 为应对 panic，展开或终止(abort)调用栈">​</a></h4><ul><li>默认情况下，当 panic 发生：<ul><li>程序展开调用栈(工作量大)<ul><li>Rust 沿着调用栈往回走</li><li>清理每个遇到的函数中的数据</li></ul></li><li>或立即中止调用栈：<ul><li>不进行清理，直接停用程序</li><li>内存需要 OS 进行清理</li></ul></li></ul></li><li>想让二进制文件更小，把设置从”展开“改为”中止“<ul><li>在 Cargo.toml 中适当的 profile 部分设置：<ul><li>panic = &#x27;abort&#x27;</li></ul></li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // panic!(&quot;crash and burn&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, v[99]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="913-使用-panic产生的回溯信息">9.1.3 使用 panic!产生的回溯信息<a href="#913-使用-panic产生的回溯信息" class="hash-link" aria-label="Direct link to 9.1.3 使用 panic!产生的回溯信息" title="Direct link to 9.1.3 使用 panic!产生的回溯信息">​</a></h4><ul><li>panic!可能出现在：<ul><li>我们写的代码中</li><li>我们所依赖的代码中</li></ul></li><li>可通过调用 panic!的函数的回溯信息来定位引起问题的代码</li><li>通过设置环境变量 RUST_BACKTRACE 可得到回溯信息(直接编译器 run 也行)</li><li>为了获取带有调试信息得回溯，必须启用调试符号（不带 --release）</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="92-result-与可恢复的错误">9.2 Result 与可恢复的错误<a href="#92-result-与可恢复的错误" class="hash-link" aria-label="Direct link to 9.2 Result 与可恢复的错误" title="Direct link to 9.2 Result 与可恢复的错误">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="921-result-枚举">9.2.1 Result 枚举<a href="#921-result-枚举" class="hash-link" aria-label="Direct link to 9.2.1 Result 枚举" title="Direct link to 9.2.1 Result 枚举">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum Result&lt;T,E&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Ok(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Err(E)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>T:操作成功情况下，Ok 变体里返回的数据的类型</li><li>Err：操作失败情况下，Err 变体里返回的错误的类型</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="922-处理-result-的一种方式match-表达式">9.2.2 处理 Result 的一种方式：match 表达式<a href="#922-处理-result-的一种方式match-表达式" class="hash-link" aria-label="Direct link to 9.2.2 处理 Result 的一种方式：match 表达式" title="Direct link to 9.2.2 处理 Result 的一种方式：match 表达式">​</a></h4><ul><li>和 Option 枚举一样，Result 及其变体也是由 prelude 带入作用域</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::{fs::File, io::ErrorKind};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = match f {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(file) =&gt; file,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(error) =&gt; match error.kind() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Ok(fc) =&gt; fc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Err(e) =&gt; panic!(&quot;Error creating file:{:?}&quot;, e),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            other_error =&gt; panic!(&quot;Error opening the file:{:?}&quot;, other_error),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>匹配不同的错误</strong></p><ul><li>上面的例子中使用了很多 match</li><li>match 很有用，但是很原始</li><li>闭包（closure）。Result&lt;T,E<!-- -->&gt;<!-- -->有很多方法：<ul><li>它们接收闭包作为参数</li><li>使用 match 实现</li><li>使用新的方法会使代码变得更加简洁</li></ul></li></ul><p><strong>unwrap</strong></p><ul><li>unwrap：match 表达式的一个快捷方法：<ul><li>如果 Result 结果是 Ok，返回 Ok 里面的值</li><li>如果 Result 结果是 Err，调用 panic!宏</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::{fs::File, io::ErrorKind};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if error.kind() == ErrorKind::NotFound {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                panic!(&quot;Error creating file:{:?}&quot;, error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            panic!(&quot;Error opening file:{:?}&quot;, error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>expect</strong></p><ul><li>expect：和 unwrap 类似，但可指定错误信息</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="923-传播错误">9.2.3 传播错误<a href="#923-传播错误" class="hash-link" aria-label="Direct link to 9.2.3 传播错误" title="Direct link to 9.2.3 传播错误">​</a></h4><ul><li>在函数出处处理错误</li><li>将错误返回给调用者</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut f = match f {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(file) =&gt; file,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(e) =&gt; return Err(e),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match f.read_to_string(&amp;mut s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(_) =&gt; Ok(s),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(e) =&gt; Err(e),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>?运算符</strong></p><ul><li>?运算符：传播错误的一种快捷方式</li><li>如果 Result 是 Ok：Ok 中的值就是表达式的结果，然后继续执行程序</li><li>如果 Result 是 Err：Err 就是整个函数的返回值，就像使用了 return</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut f = File::open(&quot;hello.txt&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f.read_to_string(&amp;mut s)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>?与 from 函数</strong></p><ul><li>Trait std::convert::From 上的 from 函数：<ul><li>用于错误之间的转换</li></ul></li><li>被?所应用的错误，会隐式的被 from 函数处理</li><li>当?调用 from 函数时：<ul><li>它所接收的所悟类型会被转换为当前函数返回类型所定义的错误类型</li></ul></li><li>用于：针对不同错误原因，返回同一种错误类型<ul><li>只要每个错误类型实现了转换为所返回的错误类型的 from 函数</li></ul></li></ul><p><strong>链式调用</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>?运算符只能用于返回 Result 的函数</strong></p><ul><li>最初 main 函数返回的类型是：()</li><li>main 函数类型也可以是 Result</li><li>Box&lt;dyn Error<!-- -->&gt;<!-- --> 是 trait 对象</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{error::Error, fs::File};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="94-什么时候应该使用-panic">9.4 什么时候应该使用 panic!<a href="#94-什么时候应该使用-panic" class="hash-link" aria-label="Direct link to 9.4 什么时候应该使用 panic!" title="Direct link to 9.4 什么时候应该使用 panic!">​</a></h3><p>总体原则</p><ul><li>在定义一个可能失败的函数时，优先考虑返回 Result</li><li>否则就 panic!</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="941-编写实例原型代码测试">9.4.1 编写实例、原型代码、测试<a href="#941-编写实例原型代码测试" class="hash-link" aria-label="Direct link to 9.4.1 编写实例、原型代码、测试" title="Direct link to 9.4.1 编写实例、原型代码、测试">​</a></h4><ul><li>可以使用 panic!<ul><li>演示某些概念：unwrap</li><li>原型代码：unwrap、expect</li><li>测试：unwrap、expect</li></ul></li></ul><p><strong>有时候你比编译器掌握更多的信息</strong></p><ul><li>你可以确定 Result 就是 Ok：unwrap</li><li>例子</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::net::IpAddr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>错误处理的指导性建议</strong></p><ul><li>当代码最终可能处于损坏状态时，最好使用 panic!</li><li>损坏状态（Bad state）：某些假设、保证、约定或不可变性被打破<ul><li>例如非法的值、矛盾的值或空缺的值被传入代码</li><li>以及下列中的一条<ul><li>这种损坏状态并不是预期能够偶尔发生的事情。</li><li>在此之后，您的代码如果处于这种损坏状态就无法运行</li><li>在您使用的类型中没有一个好的方法来将这些信息（出入损坏状态）进行编码。</li></ul></li></ul></li></ul><p><strong>场景建议</strong></p><ul><li>调用你的代码，传入无意义的参数值：panic!</li><li>调用外部不可控代码，返回非法状态，你无法修复：panic!</li><li>如果失败是可预期的：Result</li><li>当你的代码对值进行操作，首先应该验证这些值：panic!</li></ul><p><strong>为验证创建自定义类型</strong></p><ul><li>创建新的类型，把验证逻辑放在构造实例的函数里。</li><li>getter: 返回字段数据<ul><li>字段是私有的（下例中）：外部无法直接对字段赋值</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Guess {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    value: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Guess {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn new(value: i32) -&gt; Guess {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if value &lt; 1 || value &gt; 100 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            panic!(&quot;Guess value must be between 1 and 100 , got {}&quot;, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Guess { value }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn value(&amp;self) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // todo...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let guess = &quot;32&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let guess: i32 = match guess.trim().parse() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(num) =&gt; num,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(_) =&gt; continue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let guess = Guess::new(guess);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // todo...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="10-泛型trait生命周期">10 泛型，Trait，生命周期<a href="#10-泛型trait生命周期" class="hash-link" aria-label="Direct link to 10 泛型，Trait，生命周期" title="Direct link to 10 泛型，Trait，生命周期">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="101-提取函数消除重复的代码">10.1 提取函数消除重复的代码<a href="#101-提取函数消除重复的代码" class="hash-link" aria-label="Direct link to 10.1 提取函数消除重复的代码" title="Direct link to 10.1 提取函数消除重复的代码">​</a></h3><ul><li>重复代码的危害：<ul><li>容易出错</li><li>需求变更时需要在多处进行修改</li></ul></li><li>消除重复：提取函数</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn largest(list: &amp;[i32]) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for &amp;item in list {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            largest = item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let number_list = vec![34, 50, 25, 6000, 65];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>消除重复的步骤</strong></p><ul><li>识别重复代码</li><li>提取重复代码到函数体中，并在函数签名中指定函数的输入和返回值</li><li>将重复的代码使用函数调用进行替代</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="102-泛型">10.2 泛型<a href="#102-泛型" class="hash-link" aria-label="Direct link to 10.2 泛型" title="Direct link to 10.2 泛型">​</a></h3><ul><li>泛型：提高代码<code>复用</code>能力<ul><li>处理重复代码的问题</li></ul></li><li>泛型是具体类型或其它属性的抽象代替：<ul><li>你编写的代码不是最终的代码，而是一种<code>模板</code>，里面有一些<code>占位符</code>。
编译器在<code>编译时</code>将”占位符“<code>替换为具体的类型</code>。</li></ul></li><li>例如：fn largest&lt;T<!-- -->&gt;<!-- -->(list:&amp;<!-- -->[T]<!-- -->) -&gt; T{ ... }</li><li>类型参数：<ul><li>很短，通常一个字母</li><li>CamelCase</li><li>T：type 的缩写</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1021-函数定义中的泛型">10.2.1 函数定义中的泛型<a href="#1021-函数定义中的泛型" class="hash-link" aria-label="Direct link to 10.2.1 函数定义中的泛型" title="Direct link to 10.2.1 函数定义中的泛型">​</a></h4><ul><li>泛型函数：<ul><li>参数类型</li><li>返回类型</li></ul></li></ul><p>例子有点小问题，但和 typescript 差不多</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for &amp;item in list {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            largest = item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = largest(&amp;char_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The largest char is {}&quot;, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1022-struct-中定义的泛型">10.2.2 Struct 中定义的泛型<a href="#1022-struct-中定义的泛型" class="hash-link" aria-label="Direct link to 10.2.2 Struct 中定义的泛型" title="Direct link to 10.2.2 Struct 中定义的泛型">​</a></h4><ul><li>可以使用多个泛型的类型参数<ul><li>太多类型参数：你的代码需要重组为多个更小的单元</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Point&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let integer = Point { x: 5, y: 10 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let float = Point { x: 1.0, y: 4.0 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1023-enum-定义中的泛型">10.2.3 Enum 定义中的泛型<a href="#1023-enum-定义中的泛型" class="hash-link" aria-label="Direct link to 10.2.3 Enum 定义中的泛型" title="Direct link to 10.2.3 Enum 定义中的泛型">​</a></h4><ul><li>可以让枚举的变体持有泛型数据类型<ul><li>例如 Option&lt;T<!-- -->&gt;<!-- -->,Result&lt;T,E<!-- -->&gt;</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum Option&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Some(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Result&lt;T, E&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Err(E),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1024-方法定义中的泛型">10.2.4 方法定义中的泛型<a href="#1024-方法定义中的泛型" class="hash-link" aria-label="Direct link to 10.2.4 方法定义中的泛型" title="Direct link to 10.2.4 方法定义中的泛型">​</a></h4><ul><li>为 struct 或 enum 实现方法的时候，可在定义中使用泛型</li><li>注意：<ul><li>把 T 放在 impl 关键字后，表示在类型 T 上实现方法<ul><li>例如：impl&lt;T<!-- -->&gt;<!-- --> Point&lt;T<!-- -->&gt;</li></ul></li><li>只针对具体类型实现方法（其余类型没实现方法）<ul><li>例如：impl Point&lt;f32<!-- -->&gt;</li></ul></li></ul></li><li>struct 里的泛型类型参数可以和方法的泛型类型参数不同</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Point&lt;T, U&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y: U,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T, U&gt; Point&lt;T, U&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x: self.x,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            y: other.y,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let p1 = Point { x: 5, y: 4 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let p2 = Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x: &quot;Hello&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y: &quot;Rust&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let p3 = p1.mixup(p2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1025-泛型代码的性能">10.2.5 泛型代码的性能<a href="#1025-泛型代码的性能" class="hash-link" aria-label="Direct link to 10.2.5 泛型代码的性能" title="Direct link to 10.2.5 泛型代码的性能">​</a></h4><ul><li>使用泛型的代码和使用具体类型的代码运行速度是一样的。</li><li>单态话（monomorphization）：<ul><li>在编译时将泛型替换为具体类型</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let integer = Some(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let float = Some(5.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Option_i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Some(i32),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Option_f64 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Some(f64),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let integer = Option_i32::Some(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let float = Option_f64::Some(5.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="103-trait">10.3 Trait<a href="#103-trait" class="hash-link" aria-label="Direct link to 10.3 Trait" title="Direct link to 10.3 Trait">​</a></h3><ul><li>Trait 告诉 Rust 编译器：
某种类型具有哪些并且可以与其它类型共享的功能</li><li>Trait：抽象的定义共享行为</li><li>Trait bounds（约束）：泛型类型参数指定为实现了特定行为的类型</li><li>Trait 与其他语言的接口（）interface 类似，但有些区别。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1031-定义一个-trait">10.3.1 定义一个 Trait<a href="#1031-定义一个-trait" class="hash-link" aria-label="Direct link to 10.3.1 定义一个 Trait" title="Direct link to 10.3.1 定义一个 Trait">​</a></h4><ul><li>Trait 的定义：把方法签名放在一起，来定义实现某种目的所必须的一组行为。<ul><li>关键字：trait</li><li>只有方法签名，没有具体实现</li><li>trait 可以有多个方法：每个方法签名占一行，以;结尾</li><li>实现该 trait 的类型必须提供具体的方法实现</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub trait Summary {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn summarize(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1032-在类型上实现-trait">10.3.2 在类型上实现 trait<a href="#1032-在类型上实现-trait" class="hash-link" aria-label="Direct link to 10.3.2 在类型上实现 trait" title="Direct link to 10.3.2 在类型上实现 trait">​</a></h4><ul><li>与为类型实现方法类似。</li><li>不同之处：<ul><li>impl Xxxx for Tweet { ... }</li><li>在 impl 的块里，需要对 Trait 里的方法签名进行具体的实现</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub trait Summary {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn summarize(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct NewsArticle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub headline: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub location: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub author: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub content: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Summary for NewsArticle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn summarize(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Tweet {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub username: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub content: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub reply: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub retweet: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Summary for Tweet {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn summarize(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        format!(&quot;{}:{}&quot;, self.username, self.content)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use demo::Summary;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use demo::Tweet;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let tweet = Tweet {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: String::from(&quot;horse_ebooks&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content: String::from(&quot;of course, as you probably already know, people&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reply: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        retweet: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;1 new tweet:{}&quot;, tweet.summarize());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1033-实现-trait-的约束">10.3.3 实现 trait 的约束<a href="#1033-实现-trait-的约束" class="hash-link" aria-label="Direct link to 10.3.3 实现 trait 的约束" title="Direct link to 10.3.3 实现 trait 的约束">​</a></h4><ul><li>可以在某个类型上实现某个 trait 的前提条件是：<ul><li>这个类型或这个 trait 是在本地 crate 里定义的</li></ul></li><li>无法为外部类型来实现外部的 trait：<ul><li>这个限制是程序属性的一部分（也就是<code>一致性</code>）。</li><li>更具体地说是<code>孤儿原则</code>：之所以这样命名是因为父类型不在。</li><li>此规则确保其他人的代码不能破话你的代码，反之亦然</li><li>如果没有这个规则，两个 crate 可以为同一类型实现同一个 trait，Rust 就不知道应该使用哪个实现了。</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1034-默认实现">10.3.4 默认实现<a href="#1034-默认实现" class="hash-link" aria-label="Direct link to 10.3.4 默认实现" title="Direct link to 10.3.4 默认实现">​</a></h4><ul><li>默认实现的方法可以调用 trait 中其它的方法，即使这些方法没有默认实现</li><li>注意：无法从方法的重写实现里面调用默认的实现</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub trait Summary {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn summarize_author(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn summarize(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String::from(&quot;Read more...&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>Trait 作为参数</li><li>impl Trait 语法：适用于简单情况</li><li>Trait bound 语法：可用于复杂情况<ul><li>impl Trait 语法是 Trait bound 的语法糖</li></ul></li><li>使用+ 指定多个 Traitboun</li><li>Trait bound 使用 where 子句<ul><li>可以在方法签名后指定 where 子句</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1035-实现-trait-作为返回类型">10.3.5 实现 trait 作为返回类型<a href="#1035-实现-trait-作为返回类型" class="hash-link" aria-label="Direct link to 10.3.5 实现 trait 作为返回类型" title="Direct link to 10.3.5 实现 trait 作为返回类型">​</a></h4><ul><li>impl Trait 语法</li><li>注意：impl Trait 只能返回确定的同一种类型，返回可能不同类型的代码会报错</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub fn notify1(flag: bool) -&gt; impl Summary {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if flag {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        NewsArticle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            headline: String::from(&quot;hello&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            content: String::from(&quot;World&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            author: String::from(&quot;chovrio&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            location: String::from(&quot;重庆&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Tweet {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            username: &quot;chovrio&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            content: &quot;hahahah&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            reply: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retweet: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1036-使用-trait-bound">10.3.6 使用 Trait Bound<a href="#1036-使用-trait-bound" class="hash-link" aria-label="Direct link to 10.3.6 使用 Trait Bound" title="Direct link to 10.3.6 使用 Trait Bound">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for &amp;item in list.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            largest = item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>使用 Trait Bound 有条件的实现方法</strong></p><ul><li>在使用泛型类型参数的 impl 块上使用 Trait bound，我们可以有条件的为实现了特定 Trait 的类型来实现方法</li><li>也可以为实现了其它 Trait 的任意类型有条件的实现某个 Trait</li><li>为满足 Trait Bounrd 的所有类型上实现 Trait 叫做覆盖实现（blankt implementations）</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new(x: T, y: T) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self { x, y }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn cmp_display(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.x &gt;= self.y {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;The largest member is x = {}&quot;, self.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;The largest member is y ={}&quot;, self.y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str = 3.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="104-生命周期">10.4 生命周期<a href="#104-生命周期" class="hash-link" aria-label="Direct link to 10.4 生命周期" title="Direct link to 10.4 生命周期">​</a></h3><ul><li>Rust 的每个引用都有自己的生命周期</li><li>生命周期：引用保持有效的作用域</li><li>大多数情况：生命周期是隐式的、可被推断的</li><li>当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1041-生命周期-避免悬垂引用dangling-reference">10.4.1 生命周期-避免悬垂引用（dangling reference）<a href="#1041-生命周期-避免悬垂引用dangling-reference" class="hash-link" aria-label="Direct link to 10.4.1 生命周期-避免悬垂引用（dangling reference）" title="Direct link to 10.4.1 生命周期-避免悬垂引用（dangling reference）">​</a></h4><ul><li>生命周期的主要目标：避免悬垂引用（dangling reference）</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            r = &amp;x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1042-函数中的泛型生命周期">10.4.2 函数中的泛型生命周期<a href="#1042-函数中的泛型生命周期" class="hash-link" aria-label="Direct link to 10.4.2 函数中的泛型生命周期" title="Direct link to 10.4.2 函数中的泛型生命周期">​</a></h4><p><strong>&#x27;x</strong></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let string1 = String::from(&quot;abcd&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let string2 = &quot;xyz&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = longest(string1.as_str(), string2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if x.len() &gt; y.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1043-生命周期标注语法">10.4.3 生命周期标注语法<a href="#1043-生命周期标注语法" class="hash-link" aria-label="Direct link to 10.4.3 生命周期标注语法" title="Direct link to 10.4.3 生命周期标注语法">​</a></h4><ul><li>生命周期的标注不会改变引用的生命周期长度</li><li>当指定了泛型生命周期参数，函数可以接受带有任何生命周期的引用</li><li>生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1044-生命周期标注-语法">10.4.4 生命周期标注-语法<a href="#1044-生命周期标注-语法" class="hash-link" aria-label="Direct link to 10.4.4 生命周期标注-语法" title="Direct link to 10.4.4 生命周期标注-语法">​</a></h4><ul><li><p>生命周期参数名：</p><ul><li>以<code>&#x27;</code>开头</li><li>通常全小写而且非常短</li><li>很多人使用 &#x27;a</li></ul></li><li><p>生命周期标注的位置：</p><ul><li>在引用的 &amp; 符号后</li><li>使用空格将标注和引用类型分开</li></ul></li><li><p>例子</p><ul><li><p>&amp;i32 // 一个引用</p></li><li><p>&amp;&#x27;a i32 // 带有显式生命周期的引用</p></li><li><p>&amp;&#x27;a mut i32 // 带有显式生命周期的可变引用</p></li><li><p>单个生命周期标注本身没有意义</p></li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1045-函数签名中的生命周期标注">10.4.5 函数签名中的生命周期标注<a href="#1045-函数签名中的生命周期标注" class="hash-link" aria-label="Direct link to 10.4.5 函数签名中的生命周期标注" title="Direct link to 10.4.5 函数签名中的生命周期标注">​</a></h4><ul><li>泛型生命周期参数声明在：函数名和参数列表之间&lt;<!-- -->&gt;<!-- -->里</li><li>生命周期<code>&#x27;a</code>的实际生命周期是：x 和 y 两个生命周期中较小的那个</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1046-深入理解生命周期">10.4.6 深入理解生命周期<a href="#1046-深入理解生命周期" class="hash-link" aria-label="Direct link to 10.4.6 深入理解生命周期" title="Direct link to 10.4.6 深入理解生命周期">​</a></h4><ul><li>指定生命周期参数的方式依赖于函数所作的事情</li><li>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配：</li><li>如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值：<ul><li>这就是悬垂引用：该值在函数结束时就走出了作用域</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1047-struct-定义中的生命周期标注">10.4.7 Struct 定义中的生命周期标注<a href="#1047-struct-定义中的生命周期标注" class="hash-link" aria-label="Direct link to 10.4.7 Struct 定义中的生命周期标注" title="Direct link to 10.4.7 Struct 定义中的生命周期标注">​</a></h4><ul><li>Struct 里可包括：<ul><li>自持有的类型</li><li>引用：需要在每个应用上添加生命周期标注</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1048-生命周期的省略">10.4.8 生命周期的省略<a href="#1048-生命周期的省略" class="hash-link" aria-label="Direct link to 10.4.8 生命周期的省略" title="Direct link to 10.4.8 生命周期的省略">​</a></h4><ul><li>我们知道：<ul><li>每个引用都有生命周期</li><li>需要为使用生命周期的函数或 struct 指定生命周期参数</li></ul></li></ul><p><strong>省略规则</strong></p><ul><li>在 Rust 引用分析所编入的模式称为<code>生命周期省略规则</code>。<ul><li>这些规则无需开发者来遵守</li><li>它们是一些特殊情况，由编译器来考虑</li><li>如果你的代码符合这些情况，那么就无需显式标注生命周期</li></ul></li><li>生命周期省略规则不会提供完整的推断：<ul><li>如果应用规则后，引用的生命周期仍然模糊不清 -&gt; 编译错误</li><li>解决办法：添加生命周期标注，表明引用间的相互关系</li></ul></li></ul><p><strong>输入、输出生命周期</strong></p><ul><li>生命周期在:<ul><li>函数/方法的参数：输入生命周期</li><li>函数/方法的返回值：输出生命周期</li></ul></li></ul><p><strong>生命周期省略的三个规则</strong></p><ul><li>编译器使用 3 个规则在没有显式标注生命周期的情况下，来确定引用的生命周期<ul><li>规则 1 应用于输入生命周期</li><li>规则 2、3 应用于输出生命周期</li><li>如果编译器应用完 3 个规则之后，仍然有无法确定生命周期的应用 -&gt; 报错</li><li>这些规则适用于 fn 定义和 impl 块</li></ul></li><li>规则 1：每个引用类型的参数都有自己的生命周期</li><li>规则 2：如果只有一个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数</li><li>规则 3：如果有多个输入生命周期参数，但其中一个是&amp;self 或&amp;mut self（是方法），那么 self 的生命周期会被赋给所有的输出生命周期参数</li></ul><p><strong>生命周期省略的三个规则 - 例子</strong></p><ul><li><p>假设我们是编译器</p></li><li><p>fn first_word(s:&amp;str) -&gt; {}</p></li><li><p>fn first_word&lt;&#x27;a&gt;(s:&amp;&#x27;a str) -&gt; &amp;star {}</p></li><li><p>fn first_word&lt;&#x27;a&gt;(s:&amp;&#x27;a str) -&gt; &amp;&#x27;a str {}</p></li><li><p>fn longest(x:&amp;str,y:&amp;str) -&gt; &amp;str {}</p></li><li><p>fn longest&lt;&#x27;a,&#x27;b&gt;(x:&amp;&#x27;a str,y:&amp;&#x27;b str) -&gt; &amp;str {}</p></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1048-方法定义中的生命周期标注">10.4.8 方法定义中的生命周期标注<a href="#1048-方法定义中的生命周期标注" class="hash-link" aria-label="Direct link to 10.4.8 方法定义中的生命周期标注" title="Direct link to 10.4.8 方法定义中的生命周期标注">​</a></h4><ul><li>在 struct 上使用生命周期实现方法，语法和泛型参数的语法一样</li><li>在哪声明和使用生命周期参数，依赖于：<ul><li>生命周期参数是否和字段、方法的参数或返回值有关</li></ul></li><li>struct 字段的生命周期名：<ul><li>在 impl 后声明</li></ul></li><li>impl 块内的方法签名中：<ul><li><code>引用</code>必须绑定于 struct 字段引用的声明周期，或者引用是<code>独立</code>的也可以</li><li>生命周期省略规则经常使得方法中的生命周期标注不是必须的。</li></ul></li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct ImportantExcerpt&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    part: &amp;&#x27;a str,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn level(&amp;self) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Attention please:{}&quot;, announcement);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.part</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1049-静态生命周期">10.4.9 静态生命周期<a href="#1049-静态生命周期" class="hash-link" aria-label="Direct link to 10.4.9 静态生命周期" title="Direct link to 10.4.9 静态生命周期">​</a></h4><ul><li><code>&#x27;static</code> 是一个特殊的生命周期：整个程序的持续时间。<ul><li>例如：所有的字符串字面值都拥有&#x27;static 生命周期<ul><li>let s:&amp;&#x27;static str = &quot;I have a static lifetime.&quot;;</li></ul></li></ul></li><li>为引用指定&#x27;static 生命周期前要三思：<ul><li>是否需要引用在程序整个生命周期内都存活</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10410-泛型参数类型trait-bound生命周期">10.4.10 泛型参数类型、Trait Bound、生命周期<a href="#10410-泛型参数类型trait-bound生命周期" class="hash-link" aria-label="Direct link to 10.4.10 泛型参数类型、Trait Bound、生命周期" title="Direct link to 10.4.10 泛型参数类型、Trait Bound、生命周期">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt::Display;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn longest_with_an_announcement&lt;&#x27;a, T&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str, ann: T) -&gt; &amp;&#x27;a str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T: Display,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Announcement! {}&quot;, ann);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if x.len() &gt; y.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rust/rust基础入门/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/festudy/docs/category/rust"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">rust</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#3数据" class="table-of-contents__link toc-highlight">3.数据</a><ul><li><a href="#31-变量与可变性" class="table-of-contents__link toc-highlight">3.1 变量与可变性</a></li><li><a href="#32-数据类型" class="table-of-contents__link toc-highlight">3.2 数据类型</a></li><li><a href="#33-复合类型" class="table-of-contents__link toc-highlight">3.3 复合类型</a></li><li><a href="#34-函数" class="table-of-contents__link toc-highlight">3.4 函数</a></li><li><a href="#35-控制流" class="table-of-contents__link toc-highlight">3.5 控制流</a></li><li><a href="#rust-的循环" class="table-of-contents__link toc-highlight">Rust 的循环</a></li></ul></li><li><a href="#4所有权" class="table-of-contents__link toc-highlight">4.所有权</a><ul><li><a href="#41-什么是所有权" class="table-of-contents__link toc-highlight">4.1 什么是所有权</a></li><li><a href="#413-所有权与函数" class="table-of-contents__link toc-highlight">4.1.3 所有权与函数</a></li></ul></li><li><a href="#42-引用与借用" class="table-of-contents__link toc-highlight">4.2 引用与借用</a></li><li><a href="#43-切片" class="table-of-contents__link toc-highlight">4.3 切片</a><ul><li><a href="#字符串切片" class="table-of-contents__link toc-highlight">字符串切片</a></li><li><a href="#其它类型的切片" class="table-of-contents__link toc-highlight">其它类型的切片</a></li></ul></li><li><a href="#5struct" class="table-of-contents__link toc-highlight">5.struct</a><ul><li><a href="#51-定义并实例化-struct" class="table-of-contents__link toc-highlight">5.1 定义并实例化 struct</a></li><li><a href="#52-struct-中的例子" class="table-of-contents__link toc-highlight">5.2 struct 中的例子</a></li><li><a href="#53-struct-的方法" class="table-of-contents__link toc-highlight">5.3 struct 的方法</a></li></ul></li><li><a href="#6枚举与模式匹配" class="table-of-contents__link toc-highlight">6.枚举与模式匹配</a><ul><li><a href="#61-定义枚举" class="table-of-contents__link toc-highlight">6.1 定义枚举</a></li><li><a href="#612-标准库中的-ipaddr" class="table-of-contents__link toc-highlight">6.1.2 标准库中的 IpAddr</a></li><li><a href="#613-为枚举定义方法" class="table-of-contents__link toc-highlight">6.1.3 为枚举定义方法</a></li><li><a href="#62-option-枚举" class="table-of-contents__link toc-highlight">6.2 Option 枚举</a></li><li><a href="#63-控制流运算符---match" class="table-of-contents__link toc-highlight">6.3 控制流运算符 - match</a></li><li><a href="#64-if-let" class="table-of-contents__link toc-highlight">6.4 if let</a></li></ul></li><li><a href="#7packagecratemodule" class="table-of-contents__link toc-highlight">7.Package，Crate，Module</a><ul><li><a href="#71-packagecrate定义-module" class="table-of-contents__link toc-highlight">7.1 Package、Crate、定义 Module</a></li><li><a href="#72-路径" class="table-of-contents__link toc-highlight">7.2 路径</a></li><li><a href="#73-use-关键字" class="table-of-contents__link toc-highlight">7.3 use 关键字</a></li><li><a href="#74-将模块拆分为不同文件" class="table-of-contents__link toc-highlight">7.4 将模块拆分为不同文件</a></li></ul></li><li><a href="#8常用的集合" class="table-of-contents__link toc-highlight">8.常用的集合</a><ul><li><a href="#81-vector" class="table-of-contents__link toc-highlight">8.1 Vector</a></li><li><a href="#82-vector-例子" class="table-of-contents__link toc-highlight">8.2 Vector-例子</a></li><li><a href="#83-string" class="table-of-contents__link toc-highlight">8.3 String</a></li><li><a href="#84-hashmap" class="table-of-contents__link toc-highlight">8.4 HashMap</a></li></ul></li><li><a href="#9错误处理" class="table-of-contents__link toc-highlight">9.错误处理</a><ul><li><a href="#91-panic-不可恢复的错误" class="table-of-contents__link toc-highlight">9.1 panic! 不可恢复的错误</a></li><li><a href="#92-result-与可恢复的错误" class="table-of-contents__link toc-highlight">9.2 Result 与可恢复的错误</a></li><li><a href="#94-什么时候应该使用-panic" class="table-of-contents__link toc-highlight">9.4 什么时候应该使用 panic!</a></li></ul></li><li><a href="#10-泛型trait生命周期" class="table-of-contents__link toc-highlight">10 泛型，Trait，生命周期</a><ul><li><a href="#101-提取函数消除重复的代码" class="table-of-contents__link toc-highlight">10.1 提取函数消除重复的代码</a></li><li><a href="#102-泛型" class="table-of-contents__link toc-highlight">10.2 泛型</a></li><li><a href="#103-trait" class="table-of-contents__link toc-highlight">10.3 Trait</a></li><li><a href="#104-生命周期" class="table-of-contents__link toc-highlight">10.4 生命周期</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/festudy/docs/前言">笔记</a></li><li class="footer__item"><a class="footer__link-item" href="/festudy/blog">blog</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/festudy/">none</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://blog.chovrio.club" target="_blank" rel="noopener noreferrer" class="footer__link-item">Blog</a></li><li class="footer__item"><a href="https://github.com/chovrio" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/festudy/assets/js/runtime~main.8a7bcb99.js"></script>
<script src="/festudy/assets/js/main.7be96d69.js"></script>
</body>
</html>